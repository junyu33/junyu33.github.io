<!DOCTYPE html>
<html lang="en">

  
    <link rel="alternate" hreflang="zh" href="/zh/2021/10/29/security01/">
  

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <!-- RSS / Atom -->
  <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  
<link rel="stylesheet" href="/css/style.css">

  <title>现充|junyu33</title>
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="head-nav">
	<div class="inner">
		<a href="/">
			现充|junyu33
		</a>
		<div class="right">
			
				<a href="/">Home</a>
				<a href="/archives">Archive</a>
				
					<a href="/categories">Categories</a>
				
				
					<a href="/tags">Tags</a>
				
				<a href="/zh">中文站</a>
			
		</div>
	</div>
</div>

  <div class="main">
    <div class="post">
    
      <nav class="lang-switch" role="navigation" aria-label="Language switch">
        
          <a class="lang-pill"
             href="/zh/2021/10/29/security01/"
             hreflang="zh">
            <span class="lang-label">中文</span>
          </a>
        
      </nav>
    

	<h1>csapp Decoding Lab</h1>
	<h1>solution</h1>
  <img src="https://img.junyu33.me/blog/security01/1.png">         
<p>(Note: This key may yield different results on different systems, or even across different IDEs within the same system, so the answer is <strong>for reference only</strong>.)</p>
<span id="more"></span>
<h1>problem analysis</h1>
<p>First, let’s paste the source code:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int prologue [] = &#123;
   0x5920453A, 0x54756F0A, 0x6F6F470A, 0x21643A6F,
   0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69,
   0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72,
   0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72,
   0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966,
   0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F,
   0x20206F74, 0x74786565, 0x65617276, 0x32727463,
   0x594E2020, 0x206F776F, 0x79727574, 0x4563200A
&#125;;

int data [] = &#123;
   0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72,
   0x466D203A, 0x65693A72, 0x43646E20, 0x6F54540A,
   0x5920453A, 0x54756F0A, 0x6F6F470A, 0x21643A6F,
   0x594E2020, 0x206F776F, 0x79727574, 0x4563200A,
   0x6F786F68, 0x6E696373, 0x6C206765, 0x796C656B,
   0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966,
   0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F,
   0x20206F74, 0x74786565, 0x65617276, 0x32727463,
   0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69,
   0x21687467, 0x63002065, 0x6C6C7861, 0x78742078,
   0x6578206F, 0x72747878, 0x78636178, 0x00783174
&#125;;

int epilogue [] = &#123;
   0x594E2020, 0x206F776F, 0x79727574, 0x4563200A,
   0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69,
   0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F,
   0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966,
   0x20206F74, 0x74786565, 0x65617276, 0x32727463
&#125;;

char message[100];

void usage_and_exit(char * program_name) &#123;
   fprintf(stderr, &quot;USAGE: %s key1 key2 key3 key4\n&quot;, program_name);
   exit(1);
&#125;

void process_keys12 (int * key1, int * key2) &#123;
   
   *((int *) (key1 + *key1)) = *key2;
&#125;

void process_keys34 (int * key3, int * key4) &#123;

   *(((int *)&amp;key3) + *key3) += *key4;
&#125;

char * extract_message1(int start, int stride) &#123;
   int i, j, k;
   int done = 0;

   for (i = 0, j = start + 1; ! done; j++) &#123;
      for (k = 1; k &lt; stride; k++, j++, i++) &#123;

         if (*(((char *) data) + j) == '\0') &#123;
            done = 1;
            break;
         &#125;
                      
         message[i] = *(((char *) data) + j);
      &#125;
   &#125;
   message[i] = '\0';
   return message;
&#125;

char * extract_message2(int start, int stride) &#123;
   int i, j;

   for (i = 0, j = start; 
       *(((char *) data) + j) != '\0';
       i++, j += stride) 
       &#123;
          message[i] = *(((char *) data) + j);
       &#125;
   message[i] = '\0';
   return message;
&#125;

int main (int argc, char *argv[])
&#123;
   int dummy = 1;
   int start, stride;
   int key1, key2, key3, key4;
   char * msg1, * msg2;

   key3 = key4 = 0;
   if (argc &lt; 3) &#123;
      usage_and_exit(argv[0]);
   &#125;
   key1 = strtol(argv[1], NULL, 0);
   key2 = strtol(argv[2], NULL, 0);
   if (argc &gt; 3) key3 = strtol(argv[3], NULL, 0);
   if (argc &gt; 4) key4 = strtol(argv[4], NULL, 0);

   process_keys12(&amp;key1, &amp;key2);

   start = (int)(*(((char *) &amp;dummy)));
   stride = (int)(*(((char *) &amp;dummy) + 1));

   if (key3 != 0 &amp;&amp; key4 != 0) &#123;
      process_keys34(&amp;key3, &amp;key4);
   &#125;

   msg1 = extract_message1(start, stride);

   if (*msg1 == '\0') &#123;
      process_keys34(&amp;key3, &amp;key4);
      msg2 = extract_message2(start, stride);
      printf(&quot;%s\n&quot;, msg2);
   &#125;
   else &#123;
      printf(&quot;%s\n&quot;, msg1);
   &#125;

   return 0;
&#125;


</code></pre>
<p>The program does not use the two arrays <strong>prologue</strong> and <strong>epilogue</strong>, so we can ignore them.</p>
<p>Converting the values in <strong>data</strong> into strings, we get:</p>
<pre><code class="language-C">cccccccccFFrromo
: mFr:ie ndC.TTo
:E Y.ouT.Gooo:d!
  NYowo tury. cE
hoxoscineg lkely
se3,n4 tto! fYor
oceu a  cgalol t
to  eextvraectr2
 yantd.havioind 
gth!e .caxllx tx
o xexxtrxacxt1x.

</code></pre>
<p>We can vaguely see the shadow of the plaintext (for example, words like <strong>from</strong>, <strong>friend</strong>, <strong>good</strong>), but we still need to examine the decryption function to confirm it.</p>
<p>Let’s first look at <strong>extract_message1</strong>:</p>
<pre><code class="language-C">char * extract_message1(int start, int stride) &#123;
   int i, j, k;
   int done = 0;

   for (i = 0, j = start + 1; ! done; j++) &#123;
      for (k = 1; k &lt; stride; k++, j++, i++) &#123;

         if (*(((char *) data) + j) == '\0') &#123;
            done = 1;
            break;
         &#125;
                      
         message[i] = *(((char *) data) + j);
      &#125;
   &#125;
   message[i] = '\0';
   return message;
&#125;

</code></pre>
<p>The program works as follows: starting from <strong>start+1</strong> (inclusive), it converts every <strong>stride-1</strong> data values into a string and appends them to <em>message</em>, then skips 1 data value, looping until it encounters an ASCII code of 0.</p>
<p>By visual inspection, we notice that starting from the <strong>10th character</strong> (remember, counting begins at 0), reading 2 characters and skipping 1 works perfectly, forming an English sentence like <em>(From: Friend To: You…)</em>. Thus, we can determine that <strong>start = 9</strong> and <strong>stride = 3</strong>.</p>
<p>After slightly modifying the code and running it, we obtain our <strong>first message</strong>.</p>
<hr>
<p><strong>However, this is just the first step — we still need to figure out key1 and key2.</strong></p>
<p>Then you’ll be surprised to discover:</p>
<p><strong>The key1 and key2 we input actually have nothing to do with the variables start and stride, right?</strong></p>
<p>Both <strong>start</strong> and <strong>stride</strong> are tied to the variable <strong>dummy</strong>. We must find a way to manipulate <strong>dummy</strong> through our input, thereby changing start and stride.</p>
<p><strong>This is where the magic of C pointers comes in.</strong></p>
<p>Now, let’s look at the <strong>process_keys12</strong> function:</p>
<pre><code class="language-C">void process_keys12 (int * key1, int * key2) &#123;

  

  *((int *) (key1 + *key1)) = *key2;

&#125;
</code></pre>
<p>The code essentially means: take the value stored at (<strong>address</strong> <code>key1</code> + value of <code>key1</code>) as a new address, and then assign the value of <code>key2</code> to the content at this new address. (<strong>Without some foundation in pointers, this would be really hard to figure out.</strong>)</p>
<p>Through debugging, we find that the address of <strong>dummy</strong> is <code>0x61fe04</code>, while the address of <strong>key1</strong> is <code>0x61fe00</code>. As everyone who has taken an intro CS course knows, an <code>int</code> occupies 4 bytes of memory, so the correct value for <strong>key1</strong> should be <code>1</code>.</p>
<p>Our next problem is: what value should <strong>dummy</strong> take? As readers of <em>CS:APP</em> will know, data is stored in <strong>little-endian</strong> format — lower addresses hold the low-order bytes, and higher addresses hold the high-order bytes. Clearly, <strong>start</strong> belongs to the lower address, while <strong>stride</strong> is in the higher address, with a difference of exactly <code>sizeof(char)</code>, i.e., 1 byte. One byte corresponds to two hexadecimal digits. Therefore, <strong>key2</strong> is <code>0x309</code>, which is <code>777</code> in decimal.</p>
<hr>
<p>Now, <strong>key3</strong> and <strong>key4</strong> are more troublesome. Looking at the hint from <em>message1</em>:</p>
<p><strong>“Choose a pair of key3, key4 to bypass extract1 and force the program to call extract2.”</strong></p>
<p>Let’s analyze the <strong>extract2</strong> function:</p>
<pre><code class="language-C">char * extract_message2(int start, int stride) &#123;
   int i, j;

   for (i = 0, j = start; 
       *(((char *) data) + j) != '\0';
       i++, j += stride) 
       &#123;
          message[i] = *(((char *) data) + j);
       &#125;
   message[i] = '\0';
   return message;
&#125;

</code></pre>
<p>It means: starting from <strong>start</strong>, read characters with a step size of <strong>stride</strong>. The process ends once an ASCII code of 0 is encountered.</p>
<p>By visual inspection again, we can see that when <strong>start = 9</strong> and <strong>stride = 3</strong>, we can decrypt and obtain <em>message2</em> as shown in the runtime screenshot.</p>
<p>Now the problem goes back to parameter passing. At first, I didn’t understand why we had to <strong>bypass</strong> <em>extract1</em>. After carefully analyzing the program structure, I realized:</p>
<ul>
<li>First, you cannot change the values of <strong>start</strong> and <strong>stride</strong> — otherwise, how would you decrypt correctly?</li>
<li>But if you don’t change them, then you will inevitably decrypt <em>message1</em> (since its beginning is not 0). This seems contradictory, so we need a different approach.</li>
</ul>
<p><em>One of the few available write-ups online suggests modifying the return address to jump into that annoying conditional branch. However, for some unknown reason, even when I followed that method and successfully jumped, bypassing the <code>if</code> check, the return value of <code>main</code> was still not 0 (perhaps because stack overflow triggered the compiler’s security mechanism — sometimes security really is a bad thing), which meant message2 could not be printed.</em></p>
<p>My idea, instead, is to try <strong>modifying the values in <code>data</code> within process_key34</strong>. Let’s take a look at this function:</p>
<pre><code class="language-C">void process_keys34 (int * key3, int * key4) &#123;

   *(((int *)&amp;key3) + *key3) += *key4;
&#125;

</code></pre>
<p>It’s actually quite similar to <strong>process_keys12</strong>, except that the middle <code>&quot;+&quot;</code> becomes <code>&quot;+=&quot;</code>.</p>
<p>Since <em>message1</em> reads its first character from <code>(*char)data[10]</code> (the <strong>bolded part</strong> in data[2] = 0x72<strong>46</strong>4663 — never forget little-endian order), we only need to change <code>data[2]</code> into <code>0x72004663</code> to make <em>message1</em> an empty string.</p>
<p>The next step is to offset the address of <code>(int*)&amp;key3</code> by the value of <strong>key3</strong> so that it points into <code>data[2]</code>.</p>
<img src="https://img.junyu33.me/blog/security01/2.png">  
<p><em>(Note: these addresses change each time the program runs, so the screenshot is for reference only.)</em></p>
<p>Through debugging, we can see that <code>(int*)&amp;key3</code> is at <code>0x61fdd0</code>, while the address of <code>data[2]</code> is <code>0x4030a8</code>. Since each element takes up 4 bytes, the offset is:</p>
<pre><code>(0x4030a8 - 0x61fdd0) / 4 = -553802
</code></pre>
<p>This gives us the value of <strong>key3</strong>.</p>
<p>As for <strong>key4</strong>, the goal is to turn <code>0x72464663</code> into <code>0x72004663</code>. That just means adding <code>-0x460000</code>, which is <code>-4587520</code> in decimal — the value of key4.</p>
<p><strong>Problem solved.</strong> ✅</p>
<h1>remark</h1>
<p>As a pwn enthusiast, it still took me three nights to solve this problem and finish writing up the thought process. In my view, the knowledge points involved here go a bit beyond the scope of standard textbooks (after all, the essence of C cannot be captured in just a few textbook paragraphs). If you ask a student who has just finished an introductory course and can barely distinguish between <code>&amp;</code> and <code>*</code> to tackle this problem, that would be far too much.</p>
<p><strong>But I have to admit, if you manage to solve this challenge independently</strong> (I also borrowed the approach for deriving key1 and key2), <strong>your C programming skills will have reached a whole new level — even stronger than that of an average OIer — and you’d be ready to start moving toward the binary exploitation track in CTF.</strong></p>

</div>


  </div>
</body>
</html>

