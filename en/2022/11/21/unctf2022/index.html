<!DOCTYPE html>
<html lang="en">

  
    <link rel="alternate" hreflang="zh" href="/zh/2022/11/21/unctf2022/">
  

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <!-- RSS / Atom -->
  <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  
<link rel="stylesheet" href="/css/style.css">

  <title>现充|junyu33</title>
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="head-nav">
	<div class="inner">
		<a href="/">
			现充|junyu33
		</a>
		<div class="right">
			
				<a href="/">Home</a>
				<a href="/archives">Archive</a>
				
					<a href="/categories">Categories</a>
				
				
					<a href="/tags">Tags</a>
				
				<a href="/zh">中文站</a>
			
		</div>
	</div>
</div>

  <div class="main">
    <div class="post">
    
      <nav class="lang-switch" role="navigation" aria-label="Language switch">
        
          <a class="lang-pill"
             href="/zh/2022/11/21/unctf2022/"
             hreflang="zh">
            <span class="lang-label">中文</span>
          </a>
        
      </nav>
    

	<h1>unctf2022pwn wp</h1>
	<p>Although I managed to pwn all challenges, the pwn player still lost badly.</p>
<p>The Ops level is quite frustrating; please stop putting files on Baidu Netdisk in the future.</p>
<span id="more"></span>
<h1>pwn</h1>
<h2 id="welcomeUNCTF2022">welcomeUNCTF2022</h2>
<pre><code class="language-c">int func()
&#123;
  char s2[11]; // [esp+Ch] [ebp-1Ch] BYREF
  char s[13]; // [esp+17h] [ebp-11h] BYREF

  strcpy(s2, &quot;UNCTF&amp;2022&quot;);
  puts(&quot;Welcome to UNCTF2022 Please enter the password:&quot;);
  gets(s);
  if ( !strcmp(s, s2) )
    return system(&quot;cat /flag&quot;);
  else
    return puts(&quot;wrong!!!&quot;);
&#125;
</code></pre>
<p>Simple check to test if netcat (nc) is working properly and the target machine status.</p>
<h2 id="Rock-Paper-Scissors">Rock Paper Scissors</h2>
<p>Main Section</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  char v4; // [rsp+1Fh] [rbp-1h] BYREF

  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  srand(0xAu);
  puts(&quot;Do you know \x1B[1;36m\&quot;rand()\&quot;\x1B[0m ?&quot;);
  puts(&quot;In order to help you,I can tell you a secret!!!But you need to answer my question&quot;);
  puts(&quot;Will you learn about something of pwn later?(y/n)&quot;);
  __isoc99_scanf(&quot;%c&quot;, &amp;v4);
  if ( v4 != 0x79 )
  &#123;
    puts(&quot;lazy dog,you can't know my secret and get out!!!&quot;);
    exit(0);
  &#125;
  puts(&quot;good boy,I trust you&quot;);
  puts(&quot;the secret is:&quot;);
  puts(&quot;I have set a seed for \x1B[1;36m\&quot;srand()\&quot;?\x1B[0m&quot;);
  puts(&quot;I'm so happy.Come and play games with me&quot;);
  playgame(&quot;I'm so happy.Come and play games with me&quot;);
  return 0;
&#125;
</code></pre>
<p>Game Section</p>
<pre><code class="language-c">__int64 playgame()
&#123;
  int v1; // [rsp+4h] [rbp-Ch]
  int v2; // [rsp+8h] [rbp-8h]
  int i; // [rsp+Ch] [rbp-4h]

  rules();
  for ( i = 1; i &lt;= 100; ++i )
  &#123;
    printf(&quot;\x1B[1;31mround[%d]\x1B[0m\n&quot;, (unsigned int)i);
    v2 = input();
    v1 = rand() % 3;
    if ( !v2 &amp;&amp; v1 != 1 || v2 == 1 &amp;&amp; v1 != 2 || v2 == 2 &amp;&amp; v1 )
      gameover();
    puts(&quot;success!!!&quot;);
  &#125;
  return backdoor();
&#125;
</code></pre>
<p>Given that the random seed is set, simply generate a corresponding random number sequence under the same seed in a Linux environment, and input the winning choices accordingly.</p>
<h2 id="move-your-heart">move your heart</h2>
<p>The main function follows the same logic as the second question and is omitted.</p>
<pre><code class="language-c">ssize_t back()
&#123;
  char buf[32]; // [rsp+0h] [rbp-20h] BYREF

  printf(&quot;gift:%p\n&quot;, buf);
  return read(0, buf, 0x30uLL);
&#125;
</code></pre>
<p>This is a stack pivoting scenario. The payload is roughly:</p>
<p><code>p64(pop_rdi)+p64(buf+0x18)+p64(system_plt)+b'/bin/sh\0'+p64(buf)+p64(leave_ret)</code></p>
<p>It fits just right.</p>
<h2 id="Check-in">Check-in</h2>
<p>Pretty interesting, covering integer overflow and exception handling.</p>
<h3 id="Integer-Overflow">Integer Overflow</h3>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  char nptr[32]; // [rsp+0h] [rbp-50h] BYREF
  char buf[44]; // [rsp+20h] [rbp-30h] BYREF
  size_t nbytes; // [rsp+4Ch] [rbp-4h]

  in1t(argc, argv, envp);
  puts(&quot;name: &quot;);
  read(0, buf, 0x10uLL);
  buf[16] = 0;
  puts(&quot;Please input size: &quot;);
  read(0, nptr, 8uLL);
  if ( atoi(nptr) &gt; 32 || nptr[0] == '-' )
  &#123;
    puts(&quot;No!!Hacker&quot;);
    exit(0);
  &#125;
  LODWORD(nbytes) = atoi(nptr);
  read(0, nptr, (unsigned int)nbytes);
  return 0;
&#125;
</code></pre>
<p>The <code>buf</code> variable is not particularly useful here, so we can ignore it for now.</p>
<p>Note that in the second-to-last line, the byte count is cast to an unsigned type, while <code>atoi</code> converts to <code>int</code>. This suggests a potential integer overflow vulnerability.</p>
<p>Since the first character cannot be a minus sign, it is possible to bypass this check by adding a space, which does not affect the result of <code>atoi</code>.</p>
<h3 id="sigsegv">sigsegv</h3>
<p>At this point, we can read data of unlimited length and can use methods like ROP to solve the challenge.</p>
<p>However, note that there is a <code>sigsegv_handler</code> function in <code>1nit</code>, which means that upon receiving <code>SIGSEGV</code>, the flag is directly output.</p>
<pre><code class="language-c">void __noreturn sigsegv_handler()
&#123;
  fprintf(stderr, &quot;%s\n&quot;, flag);
  fflush(stderr);
  exit(1);
&#125;
</code></pre>
<p>Therefore, simply inputting random data to overflow the stack is sufficient.</p>
<h2 id="int-0x80">int_0x80</h2>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
&#123;
  int i; // [rsp+Ch] [rbp-124h]
  char buf[264]; // [rsp+10h] [rbp-120h] BYREF
  unsigned __int64 v6; // [rsp+118h] [rbp-18h]

  v6 = __readfsqword(0x28u);
  initial(argc, argv, envp);
  mmap((void *)0x10000, 0x1000uLL, 7, 34, -1, 0LL);
  puts(&quot;hello pwn&quot;);
  read(0, buf, 0x100uLL);
  for ( i = 0; i &lt; strlen(buf) - 1; ++i )
  &#123;
    if ( ((*__ctype_b_loc())[buf[i]] &amp; 0x4000) == 0 )
      exit(0);
  &#125;
  strcpy((char *)0x10000, buf);
  MEMORY[0x10000]();
  return 0;
&#125;
</code></pre>
<p>Alphanumeric shellcode</p>
<p>You can use the AE64 library, remember to set the parameter to rsi.</p>
<h2 id="fakehero">fakehero</h2>
<p><s>Suggest renaming it to fakeheap</s> (As the name implies, a fake heap problem).</p>
<h3 id="add-Operation">add Operation</h3>
<pre><code class="language-c">__int64 __fastcall add(void **a1)
&#123;
  void **v1; // rbx
  int v3; // [rsp+1Ch] [rbp-124h] BYREF
  char buf[268]; // [rsp+20h] [rbp-120h] BYREF
  __int64 size[2]; // [rsp+12Ch] [rbp-14h] BYREF

  v3 = 0;
  puts(&quot;Hi! Welcome to UNCTF!&quot;);
  puts(&quot;index: &quot;);
  __isoc99_scanf(&quot;%u&quot;, &amp;v3);
  puts(&quot;Size: &quot;);
  __isoc99_scanf(&quot;%u&quot;, size);
  if ( LODWORD(size[0]) &gt; 0x100 )
    error();
  v1 = &amp;a1[v3];
  *v1 = malloc(LODWORD(size[0]));
  puts(&quot;Content: &quot;);
  read(0, buf, 0x100uLL);
  memcpy(a1[v3], buf, LODWORD(size[0]));
  return 0LL;
&#125;
</code></pre>
<p>Note that <code>buf</code> is copied directly from the stack and is not zeroed out, which allows leaking libc and ELF addresses. <s>But this doesn't really matter.</s></p>
<p>The more important vulnerability is the lack of bounds checking on <code>idx</code>.</p>
<h3 id="free-show-Operation">free&amp;show Operation</h3>
<pre><code class="language-c">__int64 __fastcall delete(void **a1)
&#123;
  int v2; // [rsp+1Ch] [rbp-4h] BYREF

  puts(&quot;Index: &quot;);
  __isoc99_scanf(&quot;%u&quot;, &amp;v2);
  if ( !a1[v2] )
    error();
  puts((const char *)a1[v2]);
  free(a1[v2]);
  puts(&quot;Don't be far away from me.&quot;);
  return 0LL;
&#125;
</code></pre>
<p>There's not much to say—it's a classic Use-After-Free (UAF) scenario. There is no way to edit the content in the heap after it is freed, and since there is no heap overflow earlier, it is basically impossible to perform a double free.</p>
<h3 id="Solution">Solution</h3>
<p>Observing the initialization function, the heap is executable here.</p>
<pre><code class="language-c">void init()
&#123;
  int v0; // [rsp+14h] [rbp-Ch]
  unsigned __int64 ptr; // [rsp+18h] [rbp-8h]

  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  setbuf(stderr, 0LL);
  ptr = (unsigned __int64)malloc(0x1000uLL);
  v0 = sysconf(30);
  if ( v0 == -1 )
    perror(&quot;[-] sysconf failed&quot;);
  if ( mprotect((void *)(ptr &amp; 0xFFFFFFFFFFFFF000LL), v0, 7) &lt; 0 )
    perror(&quot;[-] mprotect failed&quot;);
  free((void *)ptr);
&#125;
</code></pre>
<p>Through dynamic debugging, it is found that the pointer struct is relatively close to the return address. One can consider overwriting the return address to a heap address where shellcode has been written, and then exit to execute it.</p>

</div>


  </div>
</body>
</html>

