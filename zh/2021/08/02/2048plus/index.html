<!DOCTYPE html>
<html lang="zh">

  
    <link rel="alternate" hreflang="en" href="/en/2021/08/02/2048plus/">
  

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <!-- RSS / Atom -->
  <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  
<link rel="stylesheet" href="/css/style.css">

  <title>现充|junyu33</title>
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="head-nav">
	<div class="inner">
		<a href="/">
			现充|junyu33
		</a>
		<div class="right">
			
				<a href="/zh">首页</a>
				<a href="/zh/archives">归档</a>
				
					<a href="/zh/categories">Categories</a>
				
				
					<a href="/zh/tags">Tags</a>
				
				<a href="/">English</a>
			
		</div>
	</div>
</div>

  <div class="main">
    <div class="post">
    
      <nav class="lang-switch" role="navigation" aria-label="Language switch">
        
          <a class="lang-pill"
             href="/en/2021/08/02/2048plus/"
             hreflang="en">
            <span class="lang-label">English</span>
          </a>
        
      </nav>
    

	<h1>2048 的 mathematica 实现与改良</h1>
	<p>闲来无事，我扒出了十年前在网上复制粘贴的mma2048代码，并对其进行了改良，将2048与Threes!结合起来：</p>
<p>（由于涉及键盘操作，网页版的编译器无法操作，请自行下载mma8.0及以上版本运行）</p>
<span id="more"></span>
<p>原先的 2048，mathematica 实现如下：</p>
<pre><code class="language-mathematica">挪[左] = # //. &#123;&#123;x___, 1, a_ /; a > 1, y___&#125; :> &#123;x, a, 1, y&#125;, &#123;x___, 
        a_ /; a > 1, a_, y___&#125; :> &#123;x, 2 抓住[a], 1, y&#125;&#125; /. 抓住[a_] :&gt; a &amp;;
挪[上] = Composition[Transpose, 挪[左], Transpose];
挪[下] = Composition[Reverse, 挪[上], Reverse];
挪[右] = Composition[Transpose, 挪[下], Transpose];
加块瓦 = ReplacePart[#, 
    RandomChoice@Position[#, 1] -&gt; RandomChoice[&#123;2, 4&#125;]] &amp;;
按键 = If[格子 != 挪[#][格子], 格子 = 加块瓦[挪[#][格子]]; 总分 = Total[Total[格子]];
    Which[And @@ (格子 == 挪[#][格子] &amp; /@ &#123;左, 右, 上, 下&#125;), 
     状态 = &quot;你的得分为&quot; ToString[总分]]] &amp;;
格子 = 加块瓦[ConstantArray[1, &#123;4, 4&#125;]];
状态 = &quot;&quot;;
EventHandler[
 Dynamic[ArrayPlot[Log2@格子/17, ColorFunction -&gt; Hue, 
   ColorFunctionScaling -&gt; False, Mesh -&gt; All, 
   Epilog -&gt; &#123;MapIndexed[
      Text[If[#1 == 1, &quot;&quot;, Style[#1, &quot;Section&quot;]], #2 - &#123;0.5, 0.5&#125;] &amp;, 
      Transpose@Reverse@格子, &#123;2&#125;], 
     Text[Style[状态, Blue, 24], &#123;2, 2&#125;]&#125;]], &#123;&quot;LeftArrowKeyDown&quot; :&gt; 
   按键[左], &quot;RightArrowKeyDown&quot; :&gt; 按键[右], &quot;UpArrowKeyDown&quot; :&gt; 按键[上], 
  &quot;DownArrowKeyDown&quot; :&gt; 按键[下]&#125;]
</code></pre>
<p>我在其基础上结合了 Threes! 的规则，这里 1 只能和 2 合并，2 也只能与 1 合并，然后 3 + 3 = 6，6 + 6 = 12，就跟 2048 的规则一样了。代码随机生成 1，2，3 中的任意块且概率相等。最终的计分规则为对于大于 3 的块的计分，以 3，9，27 的指数级递增，最后求和。与原版 Threes! 区别是移动规则不是一格一格移动，以及没有随机生成高分块的特性。修改的代码如下：</p>
<pre><code class="language-mathematica">挪[左] = # //. &#123;&#123;x___, 1, a_ /; a > 1, y___&#125; :> &#123;x, a, 1, y&#125;, &#123;x___, 2, 
       4, y___&#125; :> &#123;x, 6, 1, y&#125;, &#123;x___, 4, 2, y___&#125; :> &#123;x, 6, 1, 
       y&#125;, &#123;x___, a_ /; a >= 6 && EvenQ[a], a_, y___&#125; :> &#123;x, 2 a, 1, 
       y&#125;&#125; &amp;;
挪[上] = Composition[Transpose, 挪[左], Transpose];
挪[下] = Composition[Reverse, 挪[上], Reverse];
挪[右] = Composition[Transpose, 挪[下], Transpose];
加块瓦 = ReplacePart[#, 
    RandomChoice@Position[#, 1] -&gt; RandomChoice[&#123;2, 4, 6&#125;]] &amp;;
计算分数 = Total[If[# &gt;= 6, 3^Log2[#/3], 0] &amp; /@ Flatten[#]] &amp;;
按键 = If[格子 != 挪[#][格子], 格子 = 加块瓦[挪[#][格子]];
    总分 = 计算分数[格子];
    Which[And @@ (格子 == 挪[#][格子] &amp; /@ &#123;左, 右, 上, 下&#125;), 
     状态 = &quot;游戏结束！得分：&quot; &lt;&gt; ToString[总分]]] &amp;;
格子 = 加块瓦[ConstantArray[1, &#123;4, 4&#125;]];
状态 = &quot;&quot;;
EventHandler[
 Dynamic[ArrayPlot[Log2@格子/17, ColorFunction -&gt; Hue, 
   ColorFunctionScaling -&gt; False, Mesh -&gt; All, 
   Epilog -&gt; &#123;MapIndexed[
      Text[If[#1 == 1, &quot;&quot;, Style[#1/2, &quot;Section&quot;]], #2 - &#123;0.5, 0.5&#125;] &amp;,
       Transpose@Reverse@格子, &#123;2&#125;], 
     Text[Style[状态, Blue, 20], &#123;2, 2&#125;]&#125;]], &#123;&quot;LeftArrowKeyDown&quot; :&gt; 
   按键[左], &quot;RightArrowKeyDown&quot; :&gt; 按键[右], &quot;UpArrowKeyDown&quot; :&gt; 按键[上], 
  &quot;DownArrowKeyDown&quot; :&gt; 按键[下]&#125;]
</code></pre>
<p>随便打了一局，得了 3078 分，感觉还是有一定可玩性。</p>

</div>


  </div>
</body>
</html>

